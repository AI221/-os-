--  Â¥
--load game-engine
os.loadAPI"Game-Engine/redirect"
os.loadAPI"Game-Engine/game"
local args={...}
--no terminate
local ospe=os.pullEvent
os.pullEvent = coroutine.yield

--code
osStuff.splashes ={"The cake is a lie!","I don't know what you want me to say.","Possibly the first OS with a GUI not to boot to it.",";;","SPLASH!","Top-level coroutine!","TwoOS!","startx... why not starty?","","This text is hard to re\-\-\- nevermind...","New\nline.","I like to put a little coffee in my tea---I mean---ugggh, screwed up that joke.","I like to put a little chocolate in my mil---FFFFFFFFF","The cow goes \"Man, living here for free is great!\"","for i=1,100 do \n  print\"I will not use code in class\"\nend","Out of jokes. ","Blue!!!!","3good5you","In Soviet Russia, Waldo finds YOU!","In capatalist America, bank robs YOU!","makeYouLaugh() --> \"Lol xD\"","\n\n","Turtles and Rectangles dimension in Soup"," ","Infect! 5 days to send me money or I'll wipe the computer, but secretly I already have.","LandLua","EXTERMINATE!","They are fast. Faster than you can belive! DON'T turn your back, DON'T look away, and DON'T blink!\n... good luck."}--they can't control this from code anyway

if term.usingNoColor then 
	print"Note - You do not need to use nocolor to run this OS. It natively supports basic computers."
	sleep(10)
	print"Here's access to the CraftOS shell so you can remove it."
	shell.run'/rom/programs/shell'
elseif term.isColor() then 
	osStuff.backColor = colors.black
	osStuff.textColor=colors.lime
	osStuff.promptColor=colors.yellow
	osStuff.commandColor=colors.blue
	osStuff.dirColor = colors.green
	osStuff.clearBorderColor = colors.lightGray
else
	osStuff.backColor = colors.white
	osStuff.textColor = colors.black 
	osStuff.promptColor = colors.black 
	osStuff.commandColor = colors.black 
	osStuff.dirColor = colors.black
	osStuff.clearBorderColor = colors.black
end 
local noSplash
local runProg = args[2]
if args[1] then
	if string.find(args[1],"nosplash") then 
		noSplash=true
	end
end
function osStuff.specialPrint(text,time)--fancy name printing
	text = text or ""
	time = time or 0
	for i=1,#text do
		--get the cursor y pos
		local x,y=term.getCursorPos()
		if x==1 then
			x=2
		end
		term.setCursorPos(x-1,y)
		term.setBackgroundColor(osStuff.backColor)
		term.setTextColor(osStuff.textColor)
		local writeThis = string.sub(text,i,i)
		if writeThis=="\n" then--new line
			term.setBackgroundColor(osStuff.backColor or 1)
			print" "
			term.setCursorPos(1,y+1)
		else
			write(writeThis)
			term.setBackgroundColor(colors.white)
			write" "
			sleep(time)
		end
	end
	term.setBackgroundColor(osStuff.backColor or 1)
	local _,y=term.getCursorPos()
	term.setCursorPos(term.getCursorPos()-1,y)
	print" "
end
local accType,accPass
function osStuff.int()
	term.setBackgroundColor(osStuff.backColor or 1)
	term.setTextColor(osStuff.textColor or 1)
	term.clear()
	term.setCursorPos(1,1)
	term.setCursorBlink(false)
	local r = math.random(1,150)--1/50 chance to get easter egg
	if r==1 then 
		osStuff.specialPrint"GLaDOS V2"
		noSplash = false 
		osStuff.splashes = {"Oh, how are you holding up? BECAUSE I'M A POTATO."}
	elseif r==2 then 
		osStuff.specialPrint"Illuminati Secrets Browser V3"
		noSplash = false 
		osStuff.splashes = {"Yes, blame bush.\nIt makes our life MUCH easier."}
	elseif r==3 then 
		osStuff.specialPrint"Badwolf VBadwolf.badwolf"
		noSplash = false 
		osStuff.splashes={"Badwolf."}
	else 
		osStuff.specialPrint"[os] V0"
	end
	--let's select from one of our fine splashes
	if not noSplash then
		local whichSplash = math.random(1,#osStuff.splashes)
		--print the splash
		osStuff.specialPrint(osStuff.splashes[whichSplash])

	else 
		term.setCursorPos(1,2)
	end
	term.setCursorBlink(true)
	--request password
	if args[3]~="nopass" then 
		local a = loadfile"library/pswd"
		local ok,err,pss=pcall(a)
		accType = err
		accPass = pss
		if not ok then
			while true do 
				coroutine.yield() 
			end 
		end 
	end
	--display MOTD
	local a = fs.open("/library/motd","r")
	local f 
	if a then 
		f = a.readAll() 
		a.close() 
	end 
	print(f or "")
	--now they can terminate
	os.pullEvent=ospe
	if r==3 then 
		print"Badwolf badwolf to badwolf the badwolf."
	elseif r==2 then 
		print"Type Illuminati to start the secrets browser."
	elseif r==1 then 
		print"Type GLaDOS to start GLaDOS."
	else
		print"Run startx to start the GUI."
	end 
	if runProg then 
		pcall(function() shell.run(runProg) end)
	end 
	while true do
		osStuff.doMain()
	end

end
function osStuff.doDir()
--cursor crap
	if shell.dir()=="" then else--not a dir not a problem
		term.setTextColor(osStuff.dirColor)
		term.setBackgroundColor(osStuff.backColor)
		local a = string.gsub(string.upper(shell.dir()).." ","/"," - ")
		write(a)
		if #a>=term.getSize()-1 then 
			print()
		end
	end
end
function osStuff.centerWrite(text)
	local _,y=term.getCursorPos()
	term.setCursorPos((term.getSize()-#text)/2,y)
	write(text)
end
function osStuff.centerPrint(text)
	osStuff.centerWrite(text)
	print()
end
function osStuff.giveFenv(program)
	local f=getfenv()
	return setfenv(program,f)
end
--meta stuff, based of off lyqyd's code @ http://www.computercraft.info/forums2/index.php?/topic/18646-
--modifications to standard found @ http://jacksonmcneill.ddns.net/[os]_meta
-- Create local references to fs functions before they are modified
local accountType = "app" --Changing this can configure what apps are treated as. Treated as "app" by default.
-- Create local references to meta functions, as these could be changed by the user:

-- Create local references to overwritten fs functions
local isReadOnly = fs.isReadOnly
local open = fs.open 
local delete = fs.delete
local copy = fs.copy 
local move = fs.move



local function parseMeta(metaPath)
	if fs.exists(metaPath) then
		local handle = open(metaPath, "r")
		if handle then
			local data = {}
			local fn, err = loadstring(handle.readAll())
			handle.close()
			if fn then
				setfenv(fn, data)
				local success, err = pcall(fn)
				if success then
					return data
				else
					return nil, err
				end
			else
				return nil, err
			end
		else
			return nil, "could not read metadata"
		end
	else
		return nil, "no metadata found"
	end
end
function osStuff.getMetadataForFile(path)
	return parseMeta(fs.combine(".meta", path))
end
local function getMetadataForFolder(folderPath, metadata)
	if not metadata then metadata = {} end
	for _, file in ipairs(fs.list(folderPath)) do
		local path = fs.combine(folderPath, file)
		if fs.isDir(path) then
			getMetadataForFolder(path, metadata)
		else
			metadata[file] = parseMeta(path) --modified: changed path to file. This will remove the ".meta/" prefix.
		end
	end
	return metadata
end

function osStuff.getAllMetadata()
	if fs.exists(".meta") and fs.isDir(".meta") then
		return getMetadataForFolder(".meta")
	else
		return nil, "no metadata available"
	end
end
local getAllMeta = osStuff.getAllMetadata
local getFile = osStuff.getMetadataForFile
local getMetaForFile = osStuff.getMetadataForFile -- We need a local reference so they cannot modify it
local function writeMeta(file,name,auth,ftype,times,perm,otherStuff)
	local a = getMetaForFile(file)
	if not a then --creating new 
		if game.inputCheck({file,name,auth,ftype,times,perm,otherStuff},{{"string"},{"string",},{"string",},{"string",},{"table",},{"table"},{"table","nil"}},"osStuff.writeMeta(internal)(new)") then 
			return false 
		end 
		a={}
		a.name = name
		a.author = auth
		a.type = ftype 
		a.timestamp = times 
		a.permissions = perm
	else --overwriting old
		if game.inputCheck({file,name,auth,ftype,times,perm,otherStuff},{{"string"},{"string","nil"},{"string","nil"},{"string","nil"},{"table","nil"},{"table","nil"},{"table","nil"}},"osStuff.writeMeta(internal)(changing)") then 
			return false 
		end
		a.name = name or a.name
		a.author = auth or a.author
		a.type = ftype or a.type 
		
		times = times or {}
		times.accessed = times.accessed or (a.timestamp or {}).accessed
		times.modified = times.modified or (a.timestamp or {}).modified
		times.created = times.created or (a.timestamp or {}).created
		a.timestamp = times or a.timestamp 
		perm = perm or {}
		perm.admin = perm.admin or (a.permissions or {}).admin
		perm.app = perm.app or (a.permissions or {}).app
		perm.guest = perm.guest or (a.permissions or {}).guest
		a.permissions = perm or a.permissions
	end 
	-- Are they an admin? 

	--write it
	local c =""
	for i,o in pairs(a) do 
		if type(o)=="string" then 
			c=c..i.." = '"..o.."'\n"
		elseif type(o)=="table" then
			c=c..i.." = "..textutils.serialize(o).."\n"
		else 
			return game.e("Unexpected variable while piecing together string: "..type(o))
		end 
	end 
	--game.l(c) ----debug
	c=c.."\n"..(otherStuff or "")
	local b = open(fs.combine(".meta", file),"w")
	b.write(c)
	b.close()
end 
function osStuff.writeMeta(file,name,auth,ftype,times,perm,pass)
	if pass == accPass then 
		-- Do they have access?
		local b = getMetaForFile(file)
		if b then 
			if b.permissions then 
				if b.permissions["admin"] then --if admin doesn't exist, let them slide
					if b.permissions[accType] ~= 2 then
						return game.e"You do not have permission to access this file!"
					end 
				end 
			end
		end 
		if accType ~="admin" then 
			permissions = permissions or {}
			permissions.admin = 2 
			permissions.guest = 2
			--they are allowed to configure app permissions
		end 
		writeMeta(file,name,auth,ftype,times,perm)
		return true
	end 
	return false
end 


function osStuff.appMeta(file,name,auth,ftype,times)
	local a = getMetadataForFile(file)
	if not a then --creating new 
		if game.inputCheck({file,name,auth,ftype,times},{{"string"},{"string",},{"string",},{"string",},{"table",}},"appMeta(new)") then 
			return false 
		end
		local permissions = {admin = 2, guest = 2, apps = 2}
	else 
		if game.inputCheck({file,name,auth,ftype,times,perm},{{"string"},{"string","nil"},{"string","nil"},{"string","nil"},{"table","nil"},{"table","nil"}},"appMeta(changing)") then 
			return false 
		end
		-- Do they even have access to this file? 
		local b = getMetadataForFile(file)
		if b.permissions.app ~= 2 and b.perms[accType] ~= 2 then  -- Not only do apps need perms to this, but the user using the app does too.
			return "You do not have permission to access this file!"
		end 
		
	end 
	writeMeta(file,name,auth,ftype,permissions,times)
end 
function osStuff.prgName(path)
	string.gsub(path,"/","\\")
	local a
	while true do 
		a=string.find(path,"/")
		if not a then 
			break
		end 
		path = string.sub( path, a+1, #path )
	end 
	return path 
end 







--]]



function fs.isReadOnly(file)
	local a = getFile(file)
	if a then 
		if a.permissions then 
			if a.permissions[accountType] then 
				if a.permissions[accType] == 1 then 
					if a.permissions[accountType] == 0 then 
						return "noAccess" -- Allows programs to support having no access, but unsupported programs will at least not try to write to the files
					elseif a.permissions[accountType]==1 then 
						return true 
					end 
				elseif a.permissions[accType]==0 then 
					return "noAccess"
				end 
				if a.permissions[accountType] == 1 then 
					return true 
				elseif a.permissions[accountType] == 0 then 
					return "noAccess" -- Allows programs to support having no access, but unsupported programs will at least not try to write to the files
				end 
			end 
		end 
	end 
	--print("    "..file.."    ")
	--sleep(3)
	if string.sub(shell.resolve(file),1,6) == ".meta/"  then 
		return true 
	end 
	return isReadOnly(file) -- if something didn't exist or allowed write, return the native isReadOnly.
end
local function n() return "Permission Denied"  end 
local function e() error "Permission Denied" end
local function t() end
local readOnly = fs.isReadOnly -- We have to create a local reference, or this could be easily edited.
function fs.open(file,mode)
	local a = readOnly(file) -- check meta/native read-only
	--print(a)
	if mode == "w" or mode == "a" then 
		if a then -- we'll need to return something special
			return { 
				write = e,
				writeLine = e,
				flush = e, 
				close = t,
			}
		else 
			if open(file,"r") then 
				writeMeta(file,nil,nil,nil,{modified = os.day()..", "..textutils.formatTime(os.time(),true)})
			else 
				writeMeta(file,nil,nil,nil,{created = os.day()..", "..textutils.formatTime(os.time(),true)})
			end
			return open(file,mode)
		end
	elseif mode == "r" then 
		if a == "noAccess" then 
			return {
				readLine = t, -- They will end up displaying this, most likely
				readAll = n,
				close = t,
			} 
		else 
			writeMeta(file,nil,nil,nil,{accessed = os.day()..", "..textutils.formatTime(os.time(),true)}) -- If they overwrite this, they will achieve nothing.
			return open(file,mode)
		end 
	elseif mode =="rb" then 
		if a == "noAccess" then 
			return {
				read = n, -- They will end up displaying this, most likely
				close = t,
			} 
		else 
			return open(file,mode)
		end 
	elseif mode == "wb" or mode == "ab" then 
		if a then 
			return {
				readLine = t,
				close = t,
				flush = t,
			} 
		else 
			return open(file,mode)
		end 
	end 
end 
function fs.copy(a,b)
	local c = readOnly(a) 
	local d = readOnly(b) 
	if d then
		e()
		return -- Just in case
	elseif c == "noAccess" then 
		e() 
		return -- Just in case
	end 
	return copy(a,b)
end
function fs.move(a,b)-- based of copy
	local c = readOnly(a) 
	local d = readOnly(b) 
	if d then
		e()
		return -- Just in case
	elseif c == "noAccess" then 
		e() 
		return -- Just in case
	end 
	return move(a,b)
end
function fs.delete(a)
	local b = readOnly(a)
	if b then 
		e() 
		return -- Just in case
	end 
	return delete(a) 
end
--Accessing metadata with current accounts permission: 
function osStuff.open(file,mode,pass)
	if pass == accPass then 
		-- Do they have access?
		local b = getMetaForFile(file)
		if b then 
			if b.permissions then 
				if b.permissions.admin then --we let them off if there's no admin perms set
					if b.permissions[accType] ~= 2 then 
						if not ( mode ~="a" and mode ~="w" and b.permissions[accType] == 1 ) then 
							return false,game.e"You do not have permission to access this file!"
						end 
					end
				end 
			end 
		end  
		--Are they trying to access metadata as a non-admin?
		if accType ~= "admin" and string.sub(shell.resolve(file),1,6) == ".meta/"  then 
			return false 
		end 
		return open(file,mode)
	end 
	return false
end
-- Add [os] help to the help app 
local nativeLookup = help.lookup 
local nativeTopics = help.topics
function help.lookup(topic)
	-- Favor [os] help
	help.setPath"library/help"
	local a = nativeLookup(topic)
	help.setPath"rom/help"
	local b = nativeLookup(topic)
	return a or b 
end 
function help.topics()
	--Favoring [os] help
	help.setPath"library/help"
	local a = nativeTopics()
	help.setPath"rom/help"
	local b = nativeTopics() 
	for i,o in pairs(a) do 
		table.insert(b,i,o)
	end 
	return b
end 
-- Coroutine Managment functions
local routines = {}
local buffers = {}
local protected = {"main",}
local active 
function osStuff.newRoutine(name,funct,bSizex,bSizey)
	if routines[name] then 
		return false,1
	end 
	routines[name] = coroutine.create(funct)
	if (not bSizex) or (not bSizey) then 
		local bSizex,bSizey = term.getSize()
		bSizey=bSizey-1 
	end 
	buffers[name] = redirect.createRedirectBuffer(bSizex,bSizey)
	return true 
end 
function osStuff.killRoutine(name)
	for i=1,#protected do 
		if name==protected[i] then 
			return false,1 
		end 
	end 
	routines[name] = nil
	buffers[name] = nil
	return true
end 
function osStuff.getBuffer(name)
	for i=1,#protected do 
		if name==protected[i] then 
			return false,1 
		end 
	end 
	return buffers[name] 
end 
function osStuff.listRoutines()
	local a = {}
	for i,o in pairs(routines) do 
		table.insert(a,i)
	end 
	return a 
end 
function osStuff.makeRoutineActive(name)
	for i=1,#protected do 
		if name==protected[i] then 
			return false,1 
		end 
	end 
	buffers[name].makeActive()
	active = name 
end 

