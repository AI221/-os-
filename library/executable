--  ¥
--load game-engine
local ospe=os.pullEvent
local env 
os.pullEvent = coroutine.yield
os.loadAPI"/Game-Engine/redirect"
os.loadAPI"/Game-Engine/game"
os.loadAPI"/library/buffer"
osStuff.settings = {}
osStuff.settings.useAsciiPointer = true 
osStuff.settings.capDirs = true 
osStuff.settings.useDash = true
osStuff.version = 0.4
osStuff.os = "[os]"
osStuff.TEMP = "»"
_G.omni = {} -- Omni is for things that can't be trusted unless the user permits, or for the OS itself. They have access to everything, hence the name "omni"
local args={...}
--no terminate


--code
if args[1] == "nosplash" then 
  osStuff.spashes = {""}
else 
  osStuff.splashes ={"The cake is a lie!","Possibly the first OS with a GUI not to boot to it.",";;","SPLASH!","Top-level coroutine!","TwoOS!","startx... why not starty?","","This text is hard to re\-\-\- nevermind...","New\nline.","I like to put a little coffee in my tea---I mean---ugggh, screwed up that joke.","I like to put a little chocolate in my mil---FFFFFFFFF","The cow goes \"Man, living here for free is great!\"","for i=1,100 do \n  print\"I will not use code in class\"\nend","Out of jokes. ","Blue!!!!","3good5you","In Soviet Russia, Waldo finds YOU!","In capatalist America, bank robs YOU!","makeYouLaugh() --> \"Lol xD\"","\n\n","Turtles and Rectangles dimension in Soup"," ","Infect! 5 days to send me money or I'll wipe the computer, but secretly I already have!","LandLua","EXTERMINATE!","They are fast. Faster than you can belive! DON'T turn your back, DON'T look away, and DON'T blink!\n... good luck.","]os[","Access Denied.","Zoom in 300%! Enhance resultion!","If there are motherboards, are there fatherboards too?","LinusCatTips is a thing...","World, Hello!","jacksonmcneill.ddns.net","Turning-complete? Well, it's almost done!",'IF POE WERE A TECHIE\n\nOnce upon a midnight dreary,\nfingers cramped and vision bleary,\nsystem manuals piled high\nand wasted paper on the floor,\nlonging for the warmth of bed sheets,\nstill I sat there, doing spreadsheets.\n\nHaving reached the bottom line,\nI took a floppy from the drawer.\nTyping with a steady hand,\nI then invoked the "save" command\nand waited for the disk to store,\nonly this and nothing more.\n\nDeep into the monitor peering,\nlong I sat there wond\'ring, fearing\nwhile the disk kept churning,\nturning yet to churn some more.\n"Save!" I said, "You cursed mother!\nSave my data from before!"\n\nOne thing did the phosphors answer\nonly this and nothing more, just,\n "Abort, Retry, Ignore?"\nWith my fingers pale and trembling,\nslowly toward the keyboard bending,\nlonging for a happy ending,\nhoping all would be restored,\nPraying for some guarantee,\ntimidly I pressed a key.\nBut on the screen there still persisted,\nwords appearing as before.\nGhastly grim they blinked and taunted,\nhaunted, as my patience wore, saying,\n"Abort, Retry, Ignore?"\n\nThere I sat, distraught, exhausted;\nby my own machine accosted.\nGetting up, I turned away,\nand paced across the office poor.\nAnd then I saw a dreadful sight:\na lightning bolt cut through the night.\n\nA gasp of horror overtook me,\nshook me to my very core.\nThe lightning zapped my previous data,\nlost and gone forevermore. Not even,\n"Abort, Retry, Ignore?"\n',"They told me I can't; so therefore I will.","A foo walked into a bar, took a look arround, and said, \"Hello, World!\"","I like to think of betas as a huge, beautiful wall with a garden arround it. The wall is brick, but has solid concrete in the middle of it. Oh, and there's also a gaping hole in the center that lets the hackers through.","Clippy:\nIt looks like you're trying to boot up your computer. Would you like some help?","Clippy:\nDON'T YOU DARE TELL ME TO SHUTUP! DO YOU KNOW HOW MUCH CRAP I GET? ALL I EVER WANTED TO DO WAS HELP!","I have a cookie!\nCan I have a byte?\nNo, but you can have a bit!","Help! I'm trapped in the splash factory!","That's not how this works! That's not how any of this works!","Have you gotten the 'if poe where a techie' splash that was an article I c&p'd from the internet? You're better off rebooting if you do.","I'm selling an Early Access table. It only has 3 legs, but I promise I'll add the fourth!","Do you have the system32 virus? You really need to delete that!","This splash describes itself."}--they can't control this from code anyway
end
if term.usingNoColor then 
  print"Note - You do not need to use nocolor to run this OS. It natively supports basic computers."
  sleep(5)
elseif term.isColor() then 
  osStuff.backColor = colors.black
  osStuff.textColor=colors.lime
  osStuff.promptColor=colors.yellow
  osStuff.commandColor=colors.blue
  osStuff.dirColor = colors.green
  osStuff.clearBorderColor = colors.lightGray
  osStuff.errorColor = colors.red
else
  osStuff.backColor = colors.white
  osStuff.textColor = colors.black 
  osStuff.promptColor = colors.black 
  osStuff.commandColor = colors.black 
  osStuff.dirColor = colors.black
  osStuff.clearBorderColor = colors.black
  osStuff.errorColor = colors.black
end
function osStuff.specialPrint(text,time)--fancy name printing
  text = text or ""
  time = time or 0
  for i=1,#text do
    --get the cursor y pos
    local x,y=term.getCursorPos()
    if x==1 then
      x=2
    end
    term.setCursorPos(x-1,y)
    term.setBackgroundColor(osStuff.backColor)
    term.setTextColor(osStuff.textColor)
    local writeThis = string.sub(text,i,i)
    if writeThis=="\n" then--new line
      term.setBackgroundColor(osStuff.backColor or 1)
      print" "
      --term.setCursorPos(1,y+1)
    else
      write(writeThis)
      term.setBackgroundColor(colors.white)
      write" "
      sleep(time)
    end
  end
  term.setBackgroundColor(osStuff.backColor or 1)
  local _,y=term.getCursorPos()
  term.setCursorPos(term.getCursorPos()-1,y)
  print" "
end
function osStuff.doDir()
  term.setBackgroundColor(osStuff.backColor)
  if shell.dir()=="" then else--not a dir not a problem
    term.setTextColor(osStuff.dirColor)
    local dir = shell.dir()
    if osStuff.settings.capDirs then 
      dir = string.upper(dir)
    end 
    if osStuff.settings.useDash then 
      dir = string.gsub(dir,"/"," - ")
    end 
    write(dir.." ")
    if #dir>=term.getSize()-1 then 
      print()
    end
    if osStuff.settings.useAsciiPointer then 
      local x,y = term.getCursorPos()
      term.setCursorPos(x-1,y)
    end
  end
  if osStuff.settings.useAsciiPointer then 
    term.setTextColor(osStuff.commandColor)
    write"» "
    term.setTextColor(osStuff.textColor)
  else 
    --write" "
  end
end
function osStuff.centerWrite(text)
  local _,y=term.getCursorPos()
  term.setCursorPos((term.getSize()-#text)/2,y)
  write(text)
end
function osStuff.centerPrint(text)
  osStuff.centerWrite(text)
  print()
end
function osStuff.giveFenv(program)
  local f=getfenv()
  return setfenv(program,f)
end
-- Add [os] help to the help app 
local nativeLookup = help.lookup 
local nativeTopics = help.topics
function help.lookup(topic)
  -- Favor [os] help
  help.setPath"library/help"
  local a = nativeLookup(topic)
  help.setPath"rom/help"
  local b = nativeLookup(topic)
  return a or b 
end 
function help.topics()
  --Favoring [os] help
  help.setPath"library/help"
  local a = nativeTopics()
  help.setPath"rom/help"
  local b = nativeTopics() 
  for i,o in pairs(a) do 
    table.insert(b,i,o)
  end 
  return b
end 
-- Coroutine Managment functions
local routines = {}
local buffers = {}
local requests = {}
local protected = {"main","term"}
local active
function omni.newRoutine(name,funct,buf,bSizex,bSizey)
  game.l(name)
  if routines[name] then 
    return false,1
  end 
  game.l("y")
  if name ~="main" then 
    setfenv(funct,env)
  else 
    setfenv(funct,getfenv())
  end 
  routines[name] = coroutine.create(funct)
  
  if (not bSizex) or (not bSizey) then 
    local bSizex,bSizey = term.getSize()
    bSizey=bSizey-1 
  end 
  local a = term.current()
  if buf then 
    buffers[name] = buffer.newBuf(bSizex,bSizey)
  else 
    buffers[name] = term.current()
  end 
   --first run 
  term.redirect(buffers[name])
  local _ 
  _,requests[name]=coroutine.resume(routines[name])
  term.redirect(a)
  return true 
end 
function omni.killRoutine(name)
  for i=1,#protected do 
    if name==protected[i] then 
      return false,1 
    end 
  end 
  routines[name] = nil
  buffers[name] = nil
  return true
end 
function omni.getBuffer(name)
  for i=1,#protected do 
    if name==protected[i] then 
      return false,1 
    end 
  end 
  return buffers[name] 
end 
function omni.getRoutineStatus(name)
  return coroutine.status(routines[name]) 
end
function omni.listRoutines()
  local a = {}
  for i,o in pairs(routines) do 
    table.insert(a,i)
  end 
  return a 
end 
function omni.makeRoutineActive(name,x,y)
  if (not routines[name]) or (not buffers[name]) then 
    return printError"Routine did not exist, or its buffer did not exist!"
  end 
  x,y=x or 1,y or 1
  for i=1,#protected do 
    if name==protected[i] then 
      return false,1 
    end 
  end 
  local a = term.current()
  --make last one no longer active
  if active then 
    buffers[active].makeInactive()
  end
  term.redirect(buffers[name])
  --local native = term.current()
  --function buffers[name].
  if (buffers[name] or {}).makeActive then 
    buffers[name].makeActive(x,y)
  end 
  --buffers[name].isActive = true
  --test
  
  --print'Hello,World!'
  --term.redirect(a)
  active = name 
end 
local foucusedEvents = {"key","char","mouse_click","mouse_drag","mouse_scroll",}
function omni.initRoutines()
  local cT = term.current()
  while true do 
    local a = {os.pullEvent()} -- Change to coroutine.yield
    term.redirect(cT)
    --buffers[active].blit(1,1)
    for i=1,#protected do 
    --  game.l("P "..protected[i])
      if routines[protected[i]] then 
      --  game.l("x "..protected[i])
        coroutine.resume(routines[protected[i]],unpack(a))
      end 
    end 
    -- User stuff:
    if a[1]=="mouse_click" or a[1]=="mouse_drag" or a[1]=="mouse_scroll" then 
      a[4]=a[4]-1
    end 
    for i,o in pairs(routines) do 
      --game.l(i.."s "..coroutine.status(routines[i]))-------
      if coroutine.status(routines[active]) == "dead" then 
        --the active routine is dead!
      end 
      if i~=protected[i] and coroutine.status(routines[i]) == "suspended" then 
        --term.redirect(cT)
        --game.l(textutils.serialize(buffers[i]))
        term.redirect(buffers[i]) --------
        --game.l("a: "..active)
        if active == i then 
          --game.l('1 '..(tostring(requests[i]) or ""))
          if a[1]==(requests[i] or a[1]) then 
            --print"r"
            local _
           -- game.l("Resuming routine: "..active)
            _,requests[i] = coroutine.resume(routines[i],unpack(a))
          --  game.l(tostring(_))
            --print(requests[i])
          end 
        else 
          --go through events that need focous to recieve
          local bad
          local _
          for q,w in pairs(foucusedEvents) do 
            if a[1]==w then 
              bad = true 
            end 
          end 
          for k=1,#protected do 
            if protected[i]==k then
              bad=true 
            end
          end 
          if (not bad) then 
            term.redirect(buffers[i])
    --        game.l("resuming "..i)
            _,requests[i]=coroutine.resume(routines[i],unpack(a))
      --      game.l(tostring(_))
            term.redirect(cT)
          end 
        end 
      end 
    end 
  end 
end 
--lang system:
local lang={}
--run the language file 
local b = fs.open('/library/lang/def',"r")
local c 
if b then 
  c = b.readAll()
  b.close()
end
print(fs.combine("/library/lang/",(c or "")))
local a = loadfile("/"..fs.combine("/library/lang/",(c or "")))
if type(a) ~="function" then 
  print"\nWarning: Language file is missing or has errors. lan.osLookWeird. lan.exampleOfWeird"
  print("Error: "..tostring(a))
  sleep(4)
end
if a then 
  setfenv(a,lang)
  pcall(a)
else 
  print"\nWarning: Language file is missing or has errors. lan.osLookWeird. lan.exampleOfWeird"
  sleep(4)
end 
local lan = setmetatable({},{__index=function(self,input) local res,same = osStuff.g(input) if same then return "lan."..res end return res end })
function osStuff.g(a) -- This method allows for things like 'sudo.usage'
  local f=loadstring("return lang."..a)
  setfenv(f,{lang=lang})
  local ok,err = pcall(f)
  if err then 
    return err
  end 
  return a,true
end
function osStuff.p(a)
  print(osStuff.g(a))
end 
function osStuff.switchLanguage(newLang)
  local a = fs.open('/library/lang/def',"w")
  a.write(newLang)
  a.close()
end 




------------------------------
--[[~~~Clipboard System~~~]]--
------------------------------
local clipboardStuff  = {}
function osStuff.copyToClipboard(a) 
  if type(a) == "string" then 
    table.insert(clipboardStuff,1,a)
  end 
end 
function osStuff.removeFromClipboard(num)
  table.remove(clipboardStuff,num)
end 
function osStuff.getClipboard(a)
  return clipboardStuff 
end 

--[[Term fix :
function term.clearLine(l) 
  l= l or term.getCursorPos()
  local white = ""
  for i=1,term.getSize() do 
    white = white.." "
  end 
  local x,y = term.getCursorPos()
  --term.setBackgroundColor(colors.black)
  term.setCursorPos(1,l)
  print(white)
  term.setCursorPos(x,y)
end 
--]]
--A commonly used function:
function osStuff.prgName(path)
  string.gsub(path,"/","\\")
  local a
  while true do 
    a=string.find(path,"/")
    if not a then 
      break
    end 
    path = string.sub( path, a+1, #path )
  end 
  return path 
end 
function term.native()--don't let them bypass a buffer api
  return term.current()
end 

--Overwiting printerror to use our colorscheme 
function printError(txt)
  --log to console
  game.e("printError text: "..txt)
  term.setTextColor(osStuff.errorColor)
  print(txt)
  term.setTextColor(osStuff.textColor)
end 




--settings
if fs.exists"/library/settings" then 
  shell.run"/library/settings"
end 


--Part 2: 
--¥
--[[
ARgS:
1 - "nosplash" for no splash
2 - The program to run after bootup
3 - "nopass" to bypass the password. Note that there is no way you can get the boot function to do this before entering the password. The password lock is completely safe.
4 - "stop" will cause Newshell to ceise to initialize.
]]
--config:
--aliases
shell.setAlias("lock","/library/pswd")
shell.setAlias("oldEdit","/rom/programs/edit")
shell.setAlias("list","/library/programs/dir")
shell.setAlias("ls","/library/programs/dir")
local prs = fs.list"/library/programs/"
for i=1,#prs do 
  shell.setAlias(prs[i],"/library/programs/"..prs[i])
end 


--DEBUG:
shell.setAlias("a","/library/osStuff")
--force shell.programs to include our aliases
local a = shell.programs
function shell.programs(...)
  local b = a(...)
  b[#b+1] = "lock"
  b[#b+1] = "oldEdit"
  b[#b+1] = "startx"
  b[#b+1] = "console"
  for i=1,#prs do 
    b[#b+1] = prs[i]
  end 
  return b
end
local args={...}
local pastCommands={}
local tEnv = {}
tEnv["shell"] = shell--accsess to shell
tEnv["osStuff"] = osStuff --accsess to osStuffS
--api to tell if the program has cleared the screen
local didClear
local oldClear = term.clear 
function term.clear() 
  oldClear()
  didClear = true 
end 
function osStuff.didClear() return didClear end 
function osStuff.resetClear() didClear = false end 
local accType,accPass
local open = fs.open 
function osStuff.int()
  term.setBackgroundColor(osStuff.backColor or 1)
  term.setTextColor(osStuff.textColor or 1)
  term.clear()
  term.setCursorPos(1,1)
  term.setCursorBlink(false)
  local r = math.random(1,150)--1/50 chance to get easter egg
  if r==1 then 
    osStuff.specialPrint"GLaDOS V2"
    noSplash = false 
    osStuff.splashes = {"Oh, how are you holding up? BECAUSE I'M A POTATO."}
  elseif r==2 then 
    osStuff.specialPrint"Illuminati Secrets Browser V3"
    noSplash = false 
    osStuff.splashes = {"Yes, blame bush.\nIt makes our life MUCH easier."}
  elseif r==3 then 
    osStuff.specialPrint"Badwolf VBadwolf.badwolf"
    noSplash = false 
    osStuff.splashes={"Badwolf."}
  else 
    osStuff.specialPrint("[os] V"..tostring(osStuff.version))
  end
  --let's select from one of our fine splashes
  if args[1] ~="nosplash" then
    local whichSplash = math.random(1,#osStuff.splashes)
    --print the splash
    osStuff.specialPrint(osStuff.splashes[whichSplash])

  else 
    term.setCursorPos(1,2)
  end
  term.setCursorBlink(true)
  --request password
  if args[3]~="nopass" then 
    local a = loadfile"library/pswd"
    local ok,err,pss=pcall(a,open)--pswd is allowed full fs access
    accType = err
    accPass = pss
    if not ok then
      while true do 
        coroutine.yield() 
      end 
    end 
  end
  --display MOTD
  local a = fs.open("/library/motd","r")
  local f 
  if a then 
    f = a.readAll() 
    a.close() 
  end 
  print(f or "")
  if r==3 then 
    print"Badwolf badwolf to badwolf the badwolf."
  elseif r==2 then 
    print"Type Illuminati to start the secrets browser."
  elseif r==1 then 
    print"Type GLaDOS to start GLaDOS."
  else
    print"Run startx to start the GUI."
  end 
  
  if runProg then 
    pcall(function() shell.run(runProg) end)
  end 
  while true do 
    osStuff.doMain()
  end 
end

function osStuff.getDir(program)
  local remove = #fs.getName(program)
  return string.sub(program,1,#program-remove)
end 
--meta stuff, based of off lyqyd's code @ http://www.computercraft.info/forums2/index.php?/topic/18646-
--modifications to standard found @ http://jacksonmcneill.ddns.net/[os]_meta
-- Create local references to fs functions before they are modified
local accountType = "app" --Changing this can configure what apps are treated as. Treated as "app" by default.
-- Create local references to meta functions, as these could be changed by the user:

-- Create local references to overwritten fs functions
local isReadOnly = fs.isReadOnly
--Note: The open reference is above int, because it needs it
local delete = fs.delete
local copy = fs.copy 
local move = fs.move
local isDir = fs.isDir 
local combine = fs.combine
local exists = fs.exists
local list = fs.list 
-- I misunderstood this shell function ( :P ) so here's what I thought it did. I made a local reference anyway.
local function resolve(a)
  return combine(a,"")
end 
local getDir = osStuff.getDir
--Create a local reference to sleep
local sleep = sleep 
--Create a reference to os.time() on the last password attempt
local lastTime


local function parseMeta(metaPath) -- Function by Lyqyd
  if exists(metaPath) then
    local handle = open(metaPath, "r")
    if handle then
      local data = {}
      local fn, err = loadstring(handle.readAll())
      handle.close()
      if fn then
        setfenv(fn, data)
        local success, err = pcall(fn)
        if success then
          return data
        else
          return nil, err
        end
      else
        return nil, err
      end
    else
      return nil, "could not read metadata"
    end
  else
    return nil, "no metadata found"
  end
end
function osStuff.getMetadataForFile(path) -- Function by lqyqd
  return parseMeta(combine(".meta", path))
end
local getFile = osStuff.getMetadataForFile
local function getMetadataForFolder(folderPath, metadata) -- Function by lqyyd and modified by Jackson McNeill
  if not metadata then metadata = {} end
  for _, file in ipairs(list(folderPath)) do
    local path = combine(folderPath, file)
    if isDir(path) then
      getMetadataForFolder(path, metadata)
    else
      --print('a '..path)
      metadata[path] = getFile(path)
    end
  end
  return metadata
end
osStuff.getMetadataForFolder=getMetadataForFolder
function osStuff.getAllMetadata() -- Function by Lyqyd
  if exists(".meta") and isDir(".meta") then
    return getMetadataForFolder(".meta")
  else
    return nil, "no metadata available"
  end
end
function osStuff.getLowestFolderPerms(folder,type) -- slightly copied from readonly
  local entire = getMetadataForFolder(folder)
  if not entire then return end 
  local result = 2
  for fileN,a in pairs(entire) do -- a is metadata
   -- print(fileN)print(a)
    local user
    --print(textutils.serialize(a))
    if a then 
      if a.permissions then 
        --print(a.permissions[type])
        user = a.permissions[type] or 2 
      end 
    end 
    user = user or 2 
    result = math.min(result,user) -- they both need the same priviliges or the other one is void 
  end
  return result 
end 
local getAllMeta = osStuff.getAllMetadata
local getMetaForFile = osStuff.getMetadataForFile -- We need a local reference so they cannot modify it
local lowestPerms = osStuff.getLowestFolderPerms
local function writeMeta(file,name,auth,ftype,times,perm,otherStuff)
  if string.sub(resolve(file),1,6)==".meta/" then
    return false 
  end 
  local a = getMetaForFile(file)
  --[[if isDir(file) then 
    return writeMeta(file.."/osFolderMetadata",name,auth,ftype,time,perm,otherStuff)
  end ]]
  if not a then --creating new 
    if game.inputCheck({file,name,auth,ftype,times,perm,otherStuff},{{"string"},{"string",},{"string",},{"string",},{"table",},{"table"},{"table","nil"}},"osStuff.writeMeta(internal)(new)") then 
      return false 
    end 
    a={}
    a.name = name
    a.author = auth
    a.type = ftype 
    a.timestamp = times 
    a.permissions = perm
  else --overwriting old
    if game.inputCheck({file,name,auth,ftype,times,perm,otherStuff},{{"string"},{"string","nil"},{"string","nil"},{"string","nil"},{"table","nil"},{"table","nil"},{"table","nil"}},"osStuff.writeMeta(internal)(changing)") then 
      return false 
    end
    a.name = name or a.name
    a.author = auth or a.author
    a.type = ftype or a.type 
    
    times = times or {}
    times.accessed = times.accessed or (a.timestamp or {}).accessed
    times.modified = times.modified or (a.timestamp or {}).modified
    times.created = times.created or (a.timestamp or {}).created
    a.timestamp = times or a.timestamp 
    perm = perm or {}
    perm.admin = perm.admin or (a.permissions or {}).admin
    perm.app = perm.app or (a.permissions or {}).app
    perm.guest = perm.guest or (a.permissions or {}).guest
    a.permissions = perm or a.permissions
  end 
  -- Are they an admin? 

  --write it
  local c =""
  for i,o in pairs(a) do 
    if type(o)=="string" then 
      c=c..i.." = '"..o.."'\n"
    elseif type(o)=="table" then
      c=c..i.." = "..textutils.serialize(o).."\n"
    else 
      return game.e("Unexpected variable type while piecing together string: "..type(o))
    end 
  end 
  --game.l(c) ----debug
  c=c.."\n"..(otherStuff or "")
  local b = open(combine(".meta", file),"w")
  if b then 
    b.write(c)
    b.close()
  else 
    return game.e("Could not open metadata for "..file.."!")
  end 

end 
function osStuff.writeMeta(file,name,auth,ftype,times,perm,pass)
  if lastTime then 
    if os.time()-lastTime <.02 then
      lastTime = os.time()
      return error"[os] Inputing passwords too quickly; please wait 1 second before trying a password!"
    end 
  end  
  if pass == accPass then 
    -- Do they have access?
    local b = getMetaForFile(file)
    if b then 
      if b.permissions then 
        if b.permissions[accType] then --we let them off if there's no perms set
          if b.permissions[accType] ~= 2 and accType ~= "admin" then
            return game.e"You do not have permission to access this file!"
          end 
        end 
      end
    end 
    if accType ~="admin" then 
      permissions = b.permissions or {}
      permissions.admin = 2 
      permissions.guest = 2
      --they are allowed to configure app permissions
    end 
    writeMeta(file,name,auth,ftype,times,perm)
    return true
  end 
  lastTime = os.time()
  return false

end 


function osStuff.appMeta(file,name,auth,ftype,times)
  local a = getMetaForFile(file)
  if not a then --creating new 
    if game.inputCheck({file,name,auth,ftype,times},{{"string"},{"string",},{"string",},{"string",},{"table",}},"appMeta(new)") then 
      return false 
    end
    local permissions = {admin = 2, guest = 2, apps = 2}
  else 
    if game.inputCheck({file,name,auth,ftype,times,perm},{{"string"},{"string","nil"},{"string","nil"},{"string","nil"},{"table","nil"},{"table","nil"}},"appMeta(changing)") then 
     --game.l"no"
      return false 
    end
    -- Do they even have access to this file? 
    local b = getMetaForFile(file)
    --we let them off if no permissions/no app permissions
    if b.permissions then 
      if b.permissions[accType] then 
        if b.permissions.app ~= 2 and b.permissions[accType] ~= 2 then  -- Not only do apps need perms to this, but the user using the app does too.
          if b.permissions.app or b.permissions[accType] then 
            return game.e"You do not have permission to access this file!"
          end 
        end 
      end 
    end 
  end 
  writeMeta(file,name,auth,ftype,permissions,times)
  return true 
end 








--]]



function fs.isReadOnly(file)
  if isDir(file) then 
    local level = math.min( lowestPerms(file,accType) , lowestPerms(file,accountType) )
    if level == 1 then 
      return true 
    elseif level == 0 then 
      return "noAccess"
    end 
  end 
  if string.sub(resolve(file),1,6) == ".meta/"  then 
    return true 
  end 
  local a = getFile(file)
  local user,app
  if a then 
    if a.permissions then 
      user = a.permissions[accType] or 2 
      app = a.permissions[accountType] or 2 
    end 
  end 
  user = user or 2 
  app = app or 2 
  local result = math.min(user,app) -- they both need the same priviliges or the other one is void 
  if result == 1 then 
    return true 
  elseif result == 0 then 
    return "noAccess"
  end 
  return isReadOnly(file )
end 
function osStuff.sudoReadOnly(file)
  if accType ~= "admin" then 
    if string.sub(resolve(file),1,6) == ".meta/"  then 
      return true 
    end
    local a = getFile(file)
    if a then 
      if a.permissions then 
        if a.permissions[accType] == 2 then 
          return
        elseif a.permissions[accType]== 1 then 
          return true 
        elseif a.permissions[accType] == 0 then 
          return "noAccess" 
        end 
      end 
    end 
  end 
end 

--old snippit from readOnly
--[[
      if a.permissions[accountType] then --apps
        if a.permissions[accType] == 1 then 
          if a.permissions[accountType] == 0 then --apps
            return "noAccess" -- Allows programs to support having no access, but unsupported programs will at least not try to write to the files
          elseif a.permissions[accountType]==1 then --aps
            return true 
          end 
        elseif a.permissions[accType]==0 then 
          return "noAccess"
        end 
        if a.permissions[accountType] == 1 then --apps
          return true 
        elseif a.permissions[accountType] == 0 then --apps
          return "noAccess" -- Allows programs to support having no access, but unsupported programs will at least not try to write to the files
        end 
      end 
    end 
  end --]]
local function n() return "Permission Denied"  end 
local function e() error "Permission Denied" end
local function t() end
local readOnly = fs.isReadOnly -- We have to create a local reference, or this could be easily edited.
function fs.open(file,mode)
  local a = readOnly(file) -- check meta/native read-only
  --print(a)
  if mode == "w" or mode == "a" then 
    if a then -- we'll need to return something special
      return { 
        write = e,
        writeLine = e,
        flush = e, 
        close = t,
      }
    else 
      if open(file,"r") then 
        writeMeta(file,nil,nil,nil,{modified = os.day()..", "..textutils.formatTime(os.time(),true)})
      else 
        writeMeta(file,nil,nil,nil,{created = os.day()..", "..textutils.formatTime(os.time(),true)})
      end
      return open(file,mode)
    end
  elseif mode == "r" then 
    if a == "noAccess" then 
      local readIt
      local rtn = {
        readLine = function() if not readIt then readIt = true return"Permission Denied"  end end, -- They will end up displaying this, most likely
        readAll = n,
        close = t,
      } 
      return rtn
    else 
      writeMeta(file,nil,nil,nil,{accessed = os.day()..", "..textutils.formatTime(os.time(),true)}) -- If they overwrite this, they will achieve nothing.
      return open(file,mode)
    end 
  elseif mode =="rb" then 
    if a == "noAccess" then 
      return {
        read = n, -- They will end up displaying this, most likely
        close = t,
      } 
    else 
      return open(file,mode)
    end 
  elseif mode == "wb" or mode == "ab" then 
    if a then 
      return {
        readLine = t,
        close = t,
        flush = t,
      } 
    else 
      return open(file,mode)
    end 
  end 
end 
function fs.copy(a,b)
  local c = readOnly(a) 
  local d = readOnly(b) 
  if d  == "noAccess" or d then
    e()
    return -- Just in case
  elseif c == "noAccess" then 
    e() 
    return -- Just in case
  end -- Copy the metadata
  copy( fs.combine( ".meta" , a ) , fs.combine( ".meta", b ) )
  return copy(a,b)
end
function fs.move(a,b)-- based of copy
  local c = readOnly(a) 
  local d = readOnly(b) 
  if d then
    e()
    return -- Just in case
  elseif c then 
    e() 
    return -- Just in case
  end 
  --move the metadata
  pcall(  function()  move( fs.combine( ".meta" , a ) , fs.combine( ".meta", b ) )   end  )
  return move(a,b)
end
function fs.delete(a)
  local b = readOnly(a)
  if b then 
    e() 
    return -- Just in case
  end 
  --delete metadata
  delete( fs.combine( ".meta" , a ) )
  return delete(a) 
end
--Accessing files with current accounts permission: 
function osStuff.open(file,mode,pass)
  if lastTime then 
    if os.time()-lastTime <.02 then
      lastTime = os.time()
      return error(osStuff.g"tooManyPasswords")
    end 
  end  
  if pass == accPass then 
    -- Do they have access?
    local b = getMetaForFile(file)
    if b then 
      if b.permissions then 
        if b.permissions[accType] then --we let them off if there's no perms set
          if b.permissions[accType] ~= 2 then 
            if not ( mode ~="a" and mode ~="w" and b.permissions[accType] == 1 ) then 
              return false,game.e"You do not have permission to access this file!"
            end 
          end
        end 
      end 
    end  
    --Are they trying to access metadata as a non-admin?
    if accType ~= "admin" and string.sub(resolve(file),1,6) == ".meta/"  then 
      lastTime = os.time()
      return "w"
    end 
    return open(file,mode)
  end 
  lastTime = os.time()
  return "w"
end
-- A c&p'd function
function osStuff.delete(file,pass)
  if lastTime then 
    if os.time()-lastTime <.02 then
      lastTime = os.time()
      return error"[os] Inputing passwords too quickly; please wait 1 second before trying a password!"
    end 
  end  
  if pass == accPass then 
    -- Do they have access?
    local b = getMetaForFile(file)
    if b then 
      if b.permissions then 
        if b.permissions[accType] then --we let them off if there's no perms set
          if b.permissions[accType] ~= 2 then 
            if not ( mode ~="a" and mode ~="w" and b.permissions[accType] == 1 ) then 
              return false,game.e"You do not have permission to access this file!"
            end 
          end
        end 
      end 
    end  
    --Are they trying to access metadata as a non-admin?
    if accType ~= "admin" and string.sub(resolve(file),1,6) == ".meta/"  then 
      lastTime = os.time()
      return "w"
    end 
    return delete(file)
  end
  lastTime = os.time()
  return "w"
end
------------------------------
--[[Time keeping functions]]--
------------------------------
local dif = "5"
local forward = false 
local function getRealTime(dif,forward)
  if forward then 
    dif = dif.."+hours+from+now"
  else 
    dif=dif.."+hours+ago"
  end 
  local url = "http://chronic.herokuapp.com/utc/"
  --^ this is the best thing. ever. returns in plain text, and does not need a developer key. It makes my life so much easier.

  local utc = http.get(url..dif)

  if not utc then return false end
  utc = utc.readAll()
  if not utc then return false end 
  --print(utc)
  --get these into seperate variables
  local year = utc:sub(1,utc:find("-")-1)
  --print(utc:find"-")
  --print(year)
  local month = utc:sub(utc:find"-"+1,utc:find("-",utc:find"-"+1)-1)
  month=month:gsub(" ","")
  --print(month.."e")
  local day = utc:sub(utc:find("-",utc:find"-"+1)+1,utc:find(" "))
  day=day:gsub(" ","")
  --print(day.."e")
  local clocktime = utc:sub(utc:find" "+1,utc:find(" ",utc:find" "+1)-1)

  if tonumber(clocktime:sub(1,2)) >= 13 and (not osStuff.miliTime) then
    clocktime= tostring(tonumber(clocktime:sub(1,2))-12)..string.sub(clocktime,3,#clocktime)
  end 
  clocktime=clocktime:gsub(" ","")
  --print(clocktime.."e")
  return year,month,day,clocktime
end 
local function addsecond(clocktime)
  local seconds = clocktime:sub(#clocktime-1,#clocktime)
  seconds:gsub(":"," ")
  --print(seconds)
  seconds =seconds+1
  if seconds > 59 then 
    --instead of doing any further time calculations, just ask the server again. So, this means the server is asked every minute for the time.
    return false
  end
  
  local small
  if seconds <10 then 
    seconds = tostring(seconds)
    small = true 
    seconds = "0"..seconds 
  end 
  --print("c "..clocktime:sub(1,#clocktime-2))
  return clocktime:sub(1,#clocktime-2)..seconds
end 
local year,month,day,clocktime
local function timekeeping()
  while true do
    if not clocktime then --if the server went down, we'll keep trying every second... hopefully we're not the cause of its downtime, or it's not going back up anytime soon, lol.
      year,month,day,clocktime=getRealTime(dif,forward)
    end  
    local t = addsecond(clocktime)
    if t then 
      clocktime=t 
    else 
      year,month,day,clocktime=getRealTime(dif,forward)
    end 
    --print("Year "..year.." on the "..day.." of "..month..", "..clocktime)
    os.queueEvent"clocktick"
    sleep(1)
  end  
end 
function osStuff.getTime() return year,month,day,clocktime end 


--Overwrite the Game-Engine console to work with this
local gameWritetoConsole = game.writeToConsole
function game.writeToConsole(txt)
  return gameWritetoConsole("["..(clocktime or "Clock service not started yet").."] "..txt)
end 
game.l = game.writeToConsole 
function game.writeErrorToConsole(txt)
  game.writeToConsole("[ERROR] "..txt)
  return txt 
end 
game.e=game.writeErrorToConsole







-------------------
--[[Misc. stuff]]--
-------------------
local function shallowcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
          copy[orig_key] = orig_value
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end
local DONOTENABLE = true -- If this is the update that added the GUI, then this is okay to be true. If it's any later than that at all, tell me. Also tell me to remove this comment afterwards.7
--IF THIS IS ENABLED BE DEFAULT, THEN I F**KED UP! FOR THE LOVE OF ALL THAT IS PROTECTED, TELL ME!
local function stillneivecopy(orig)
  local copy = {}
  for i,o in pairs(orig) do 
    if (i~="omni" or DONOTENABLE) then  
      copy[i] = shallowcopy(o)
    end 
  end
  return copy
end 
local runningProgram
local cur = term.current()
env = stillneivecopy(_G)
--env = _G


env.os.pullEvent = ospe
local function run(prg,pargs)
  pargs = pargs or {}
  if not prg then 
    printError(osStuff.g"Nothing"..osStuff.g"noExist")
  else
    local prog=env.shell.resolveProgram(prg)
    runningProgram = prog
    if prog then 
      local failed
      prog,failed = loadfile(prog)
      if type(prog)=="function" then 
        setfenv(prog,env)
        local ok,err = pcall(function() prog(unpack(pargs)) end)
        if (not ok) and err then 
          printError(err)
        end 
      else 
        if failed then 
          printError(failed)
        end 
      end 
    else 
      printError(input..osStuff.g"noExist")
    end 
  end 
end 
function env.os.loadAPI(path)
  local _env = setmetatable({},{__index=env})
  local pg,err = loadfile(path)
  if pg then
    setfenv(pg,_env) 
    pg()
  else 
    printError(err)
  end
  local cont = {} 
  for i,o in pairs(_env) do 
    cont[i] = o 
  end 
  env[fs.getName(path)] = cont
  return true 
end 
local function tokenise( ... ) -- Taken from CC's shell/bios
    local sLine = table.concat( { ... }, " " )
  local tWords = {}
    local bQuoted = false
    for match in string.gmatch( sLine .. "\"", "(.-)\"" ) do
        if bQuoted then
            table.insert( tWords, match )
        else
            for m in string.gmatch( match, "[^ \t]+" ) do
                table.insert( tWords, m )
            end
        end
        bQuoted = not bQuoted
    end
    return tWords
end
function os.run( _tEnv, _sPath, ... )
    local tArgs = { ... }
    local fnFile, err = loadfile( _sPath )
    if fnFile then
        local tEnv = _tEnv
        --setmetatable( tEnv, { __index = function(t,k) return _G[k] end } )
        setmetatable( tEnv, { __index = env } )
        setfenv( fnFile, tEnv )
        local ok, err = pcall( function()
            fnFile( unpack( tArgs ) )
        end )
        if not ok then
            if err and err ~= "" then
                printError( err )
            end
            return false
        end
        return true
    end
    if err and err ~= "" then
        printError( err )
    end
    return false
end

function env.shell.run( ... )
  local tWords = tokenise( ... )
  local sCommand = tWords[1]
  if sCommand then
    return run( sCommand, unpack( tWords, 2 ) )
  end
  return false
end
local function noSupport() printError"Sorry, [os] does not support multishell shell functions." end 
env.shell.openTab = noSupport
env.shell.switchTab = noSupport
env.lan = lan
function env.shell.getRunningProgram() return runningProgram end 
function osStuff.doMain()
  osStuff.doDir()
  --read input
  term.setBackgroundColor(osStuff.backColor or 1)
  term.setTextColor(osStuff.textColor or 1)
  input = read(nil,pastCommands)
  --add this to prev commands
  if string.find(input,"%a") or string.find(input,"%d") then 
    pastCommands[#pastCommands+1]=input
  end
  --sub the first part of the string out
  local inFirstChar = string.sub(input,1,1) -- This section in need of recode
  if inFirstChar ~=";" and inFirstChar~=":" then
    --top priority: make it look cool, of course!
    local _,y=term.getCursorPos()
    term.setCursorPos(1,y-1)
    osStuff.doDir()
    term.setTextColor(osStuff.commandColor or 1)
    --write(inFirstChar)
    term.setTextColor(osStuff.textColor or 1)
    --kindly done for me:
    --input=string.sub(input,2,#input)
    --write(input)
    print() --move back to normal line
    --[[if input =="clear" then
      local runThis = loadfile"library/newClear"
      runThis()
    elseif input=="wipe"then
      local runThis=loadfile"library/wipe"
      runThis()
    elseif input=="settings"then
    
      local runThis=loadfile"library/settings"
      runThis=osStuff.giveFenv(runThis)
      runThis()
    else
      
    end]]
    if input == "console" then 
      game.openConsole()
    elseif input == "startx" then 
      if term.isColor() then 
        --start the GUI
        print"not done"
      else 
        osStuff.p"noBasicGUI"
      end
    else 
      osStuff.resetClear()
      -- Execute the program
      local pargs = tokenise(input)
      if not pargs[1] then 
        printError(osStuff.g"Nothing"..osStuff.g"noExist")
      else
        local prog=shell.resolveProgram(pargs[1])
        runningProgram = prog
        table.remove(pargs,1)
        if prog then 
          local failed
          prog,failed = loadfile(prog)
          if type(prog)=="function" then 
            setfenv(prog,env)
            local ok,err = pcall(function() prog(unpack(pargs)) end)
            term.redirect(cur)
            if (not ok) and err then 
              printError(err)
            end 
          else 
            if failed then 
              printError(failed)
            end 
          end 
        else 
          printError(input..osStuff.g"noExist")
        end 
      end 
      if osStuff.didClear() then 
        local _,cury = term.getCursorPos()
        local _,termy = term.getSize()        
        term.setBackgroundColor(osStuff.backColor)
        for i=cury,termy do           
          term.setCursorPos(1,i)
          term.clearLine()
        end

        term.setCursorPos(1,cury)
      end 












      -- Reset background colors: 
      term.setBackgroundColor(osStuff.backColor)
      term.setTextColor(osStuff.commandColor)
    end
  else--RECODE THIS!!!
    --  MY EYES! THEY BUURRRNNNNN
    local inputF
    --they're running a lua command
    local _,y=term.getCursorPos()
    term.setCursorPos(1,y-1)
    osStuff.doDir()
    term.setTextColor(osStuff.promptColor or 1)
    term.setTextColor(osStuff.commandColor or 1)
    write(inFirstChar)
    term.setTextColor(osStuff.textColor or 1)
    input=string.sub(input,2,#input)
    print(input)
    --make it into a command:
    inputF,err= loadstring("return "..input)
    if err then 
      game.l"noReturn"
      game.l(type(inputF))
      inputF,err=loadstring(input)
    end
    --set its envirnment
    setfenv(inputF,tEnv)
    --call it
    game.l(inputF)
    game.l(err)
    game.l("f"..type(inputF))
    inputF()
    if type(inputF)=="function" then 
      local ok,err=pcall(inputF)
      inputF()
      game.l"yes"
      game.l(ok)
      game.l(err)
    else 
      print(err)
    end
    
    if not ok and err then
      --first let's check if it's a variablef
      local varF=loadstring("return "..input.."")
      setfenv(varF, tEnv)
      local var,errr=pcall(varF)
     -- printError("Your command had this error: \n"..err.."\nIf you want to run a program, put ; infront.")
      --could be a variable, etc.
      --check if it;s a table
      if type(var)=="table" then
        local okay,er = pcall(textutils.serialize, err)
        if okay then--did work
          print(er)
        else
          print(tostring(err))
        end
      else
        print(tostring(err))
      end
    end
  end
end

env.osStuff.doMain = osStuff.doMain --doMain would get discluded otherwise.
if args[4]~="stop" then 
  --osStuff.int()
  omni.newRoutine("term",osStuff.int,false)
  omni.newRoutine("time",timekeeping,false)--this really doesn't need a buffer
  omni.makeRoutineActive("time")
  omni.initRoutines()
end
game.l"[OS] Has finished executing. This is NOT supposed to happen!"
game.l"--the user won't see this, the console.log will never be closed. This is here so they see the above message.--"
