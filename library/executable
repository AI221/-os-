--[[
if metadata is having issue,ln 841 may be of interest, recent change there that I havn't tested well

]]
--[[
POOR FIXES: 

These are the approx. ln numbers for fixes that should probably be redone

970




]]
--[[
s=textutils.serialize
function textutils.serialize(a)
  for i,o in pairs(a) do 
    print(i) print(o) print() os.pullEvent"key"
  end 
  return s(a)
  
end ]]

--  Â¥
--load game-engine
local ospe=os.pullEvent
local env 
--[[function game.l() end 
game.e = game.l 
game.writeToConsole = game.l 
game.writeErrorToConsole = game.l ]]

os.pullEvent = coroutine.yield
os.loadAPI"/Game-Engine/redirect"
os.loadAPI"/Game-Engine/game"
os.loadAPI"/library/buffer"
osStuff.settings = {}
osStuff.settings.useAsciiPointer = false
osStuff.settings.capDirs = true 
osStuff.settings.useDash = true
osStuff.settings.timeDif = 5
osStuff.settings.timeDifPlus = false 
osStuff.settings.shortClock = true
osStuff.settings.taskSpace=2
osStuff.version = 0.5
osStuff.os = "[os]"
osStuff.TEMP = "»"
_G.omni = {} -- Omni is for things that can't be trusted unless the user permits, or for the OS itself. They have access to everything, hence the name "omni"
local args={...}
--no terminate


--code
if args[1] == "nosplash" then 
  osStuff.spashes = {""}
else 
  osStuff.splashes ={"The cake is a lie!","Possibly the first OS with a GUI not to boot to it.",";;","SPLASH!","Top-level coroutine!","TwoOS!","startx... why not starty?","","This text is hard to re\-\-\- nevermind...","New\nline.","I like to put a little coffee in my tea---I mean---ugggh, screwed up that joke.","I like to put a little chocolate in my mil---FFFFFFFFF","The cow goes \"Man, living here for free is great!\"","for i=1,100 do \n  print\"I will not use code in class\"\nend","Out of jokes. ","Blue!!!!","3good5you","In Soviet Russia, Waldo finds YOU!","In capatalist America, bank robs YOU!","makeYouLaugh() --> \"Lol xD\"","\n\n","Turtles and Rectangles dimension in Soup"," ","Infect! 5 days to send me money or I'll wipe the computer, but secretly I already have!","LandLua","EXTERMINATE!","They are fast. Faster than you can belive! DON'T turn your back, DON'T look away, and DON'T blink!\n... good luck.","]os[","Access Denied.","Zoom in 300%! Enhance resultion!","If there are motherboards, are there fatherboards too?","LinusCatTips is a thing...","World, Hello!","jacksonmcneill.ddns.net","Turning-complete? Well, it's almost done!",'IF POE WERE A TECHIE\n\nOnce upon a midnight dreary,\nfingers cramped and vision bleary,\nsystem manuals piled high\nand wasted paper on the floor,\nlonging for the warmth of bed sheets,\nstill I sat there, doing spreadsheets.\n\nHaving reached the bottom line,\nI took a floppy from the drawer.\nTyping with a steady hand,\nI then invoked the "save" command\nand waited for the disk to store,\nonly this and nothing more.\n\nDeep into the monitor peering,\nlong I sat there wond\'ring, fearing\nwhile the disk kept churning,\nturning yet to churn some more.\n"Save!" I said, "You cursed mother!\nSave my data from before!"\n\nOne thing did the phosphors answer\nonly this and nothing more, just,\n "Abort, Retry, Ignore?"\nWith my fingers pale and trembling,\nslowly toward the keyboard bending,\nlonging for a happy ending,\nhoping all would be restored,\nPraying for some guarantee,\ntimidly I pressed a key.\nBut on the screen there still persisted,\nwords appearing as before.\nGhastly grim they blinked and taunted,\nhaunted, as my patience wore, saying,\n"Abort, Retry, Ignore?"\n\nThere I sat, distraught, exhausted;\nby my own machine accosted.\nGetting up, I turned away,\nand paced across the office poor.\nAnd then I saw a dreadful sight:\na lightning bolt cut through the night.\n\nA gasp of horror overtook me,\nshook me to my very core.\nThe lightning zapped my previous data,\nlost and gone forevermore. Not even,\n"Abort, Retry, Ignore?"\n',"They told me I can't; so therefore I will.","A foo walked into a bar, took a look arround, and said, \"Hello, World!\"","I like to think of betas as a huge, beautiful wall with a garden arround it. The wall is brick, but has solid concrete in the middle of it. Oh, and there's also a gaping hole in the center that lets the hackers through.","Clippy:\nIt looks like you're trying to boot up your computer. Would you like some help?","Clippy:\nDON'T YOU DARE TELL ME TO SHUTUP! DO YOU KNOW HOW MUCH CRAP I GET? ALL I EVER WANTED TO DO WAS HELP!","I have a cookie!\nCan I have a byte?\nNo, but you can have a bit!","Help! I'm trapped in the splash factory!","That's not how this works! That's not how any of this works!","Have you gotten the 'if poe where a techie' splash that was an article I c&p'd from the internet? You're better off rebooting if you do.","I'm selling an Early Access table. It only has 3 legs, but I promise I'll add the fourth!","Do you have the system32 virus? You really need to delete that!","This splash describes itself."}--they can't control this from code anyway
end
if term.usingNoColor then 
  print"Note - You do not need to use nocolor to run this OS. It natively supports basic computers."
  sleep(5)
elseif term.isColor() then 
  osStuff.backColor = colors.black
  osStuff.textColor=colors.lime
  osStuff.promptColor=colors.yellow
  osStuff.commandColor=colors.blue
  osStuff.dirColor = colors.green
  osStuff.clearBorderColor = colors.lightGray
  osStuff.errorColor = colors.red
  --gui colors
  osStuff.settings.gc = {}
  osStuff.settings.gc.menuBColor = colors.lightBlue
  osStuff.settings.gc.menuTColor = colors.gray
  osStuff.settings.gc.borderBColor = colors.lightBlue
  osStuff.settings.gc.borderTColor = colors.gray 
else
  osStuff.backColor = colors.white
  osStuff.textColor = colors.black 
  osStuff.promptColor = colors.black 
  osStuff.commandColor = colors.black 
  osStuff.dirColor = colors.black
  osStuff.clearBorderColor = colors.black
  osStuff.errorColor = colors.black
end







--1.7 update stuff
local oldGFenv = getfenv
local oldSFenv = setfenv
function getFenv(targ)
  game.e"Depreciated function getFenv called" 
  return oldGFenv(targ)
end 
function setFenv(targ,env)
  game.e"Depreciated function setFenv called" 
  return oldSFenv(targ,env)
end 



function osStuff.specialPrint(text,time)--fancy name printing
  --[[text = text or ""
  time = time or 0
  for i=1,#text do
    --get the cursor y pos
    local x,y=term.getCursorPos()
    if x==1 then
      x=2
    end
    term.setCursorPos(x-1,y)
    term.setBackgroundColor(osStuff.backColor)
    term.setTextColor(osStuff.textColor)
    local writeThis = string.sub(text,i,i)
    if writeThis=="\n" then--new line
      term.setBackgroundColor(osStuff.backColor or 1)
      print" "
      --term.setCursorPos(1,y+1)
    else
      write(writeThis)
      term.setBackgroundColor(colors.white)
      write" "
      sleep(time)
    end
  end
  term.setBackgroundColor(osStuff.backColor or 1)
  local _,y=term.getCursorPos()
  term.setCursorPos(term.getCursorPos()-1,y) 
  print" "]]print(text)
end
function osStuff.doDir()
  term.setBackgroundColor(osStuff.backColor)
  if shell.dir()=="" then else--not a dir not a problem
    term.setTextColor(osStuff.dirColor)
    local dir = shell.dir()
    if osStuff.settings.capDirs then 
      dir = string.upper(dir)
    end 
    if osStuff.settings.useDash then 
      dir = string.gsub(dir,"/"," - ")
    end 
    write(dir.." ")
    if #dir>=term.getSize()-1 then 
      print()
    end
    if osStuff.settings.useAsciiPointer then 
      local x,y = term.getCursorPos()
      term.setCursorPos(x-1,y)
    end
  end
  if osStuff.settings.useAsciiPointer then 
    term.setTextColor(osStuff.commandColor)
    write"» "
    term.setTextColor(osStuff.textColor)
  else 
    term.setTextColor(osStuff.commandColor)
    write"> "
    term.setTextColor(osStuff.textColor)
  end
end
function osStuff.centerWrite(text)
  local _,y=term.getCursorPos()
  term.setCursorPos((term.getSize()-#text)/2,y)
  write(text)
end
function osStuff.centerPrint(text)
  osStuff.centerWrite(text)
  print()
end
function osStuff.giveFenv(program)--depreciated, soon to be removed
  game.e"osStuff.giveFenv is depreciated and may be removed soon."
  local f=getfenv()
  return setfenv(program,f)
end
-- Add [os] help to the help app 
local nativeLookup = help.lookup 
local nativeTopics = help.topics
function help.lookup(topic)
  -- Favor [os] help
  help.setPath"library/help"
  local a = nativeLookup(topic)
  help.setPath"rom/help"
  local b = nativeLookup(topic)
  return a or b 
end 
function help.topics()
  --Favoring [os] help
  help.setPath"library/help"
  local a = nativeTopics()
  help.setPath"rom/help"
  local b = nativeTopics() 
  for i,o in pairs(a) do 
    table.insert(b,i,o)
  end 
  return b
end 
-- Coroutine Management functions
local routines = {}
local buffers = {}
local oriBuffers = {}
local requests = {}
local active = {}
local props = {}
local taskOrientation = {}
local curRout
local natTerm = term.current()
function omni.newRoutine(name,funct,buf,bSizex,bSizey,dontrunFirstTime)
  game.l(name)
  if routines[name] then 
    return false,1
  end 
  game.l("y")
  if name ~="main" then 
    setfenv(funct,env)--I need a better way of doing this...
  else 
    setfenv(funct,getfenv())
  end 
  routines[name] = coroutine.create(funct)
  
  if (not bSizex) or (not bSizey) then 
    local bSizex,bSizey = term.getSize()
    bSizey=bSizey-1 
  end 
  local a = term.current()
  if buf then 
    buffers[name] = buffer.newBuf(bSizex,bSizey,natTerm)
    oriBuffers[name] = buffers[name]
  else 
    buffers[name] = term.current()
  end 
   --first run 
   if not dontrunFirstTime then 
     local prev = curRout
     curRout = name 
    term.redirect(buffers[name])
    local _ 
    _,requests[name]=coroutine.resume(routines[name])
    term.redirect(a)
  end 
  return true 
end 
function omni.killRoutine(name)--recode, will crash atm
  routines[name] = nil
  buffers[name] = nil
  return true
end 
function omni.getBuffer(name)
  return buffers[name] 
end 
function omni.getOriBuffer(name)
  return oriBuffers[name]
end 
function omni.getRoutineStatus(name)
  return coroutine.status(routines[name]) 
end
function omni.listRoutines()
  local a = {}
  for i,o in pairs(routines) do 
    table.insert(a,i)
  end 
  return a 
end 
local lastActive
function omni.legacyMakeActive(name)--*not* depreciated 
  if lastActive then 
    active[lastActive] = false
    if oriBuffers[lastActive] then 
      if oriBuffers[lastActive].makeInactive then 
        game.l("deactiv buf"..lastActive)
        oriBuffers[lastActive].makeInactive() 
      end 
    end 
  end 
  lastActive =name 
  active[name] = true 
  if oriBuffers[name] then
    if oriBuffers[name].makeActive then 
      oriBuffers[name].makeActive() 
    end 
  end 
end 
function omni.returnLegacyActive() 
  return lastActive
end 
function omni.makeActive(name)
  active[name] = true 
  if oriBuffers[name] then 
    if oriBuffers[name].makeActive then 
      oriBuffers[name].makeActive() 
    end 
  end 
end 
local foucusedEvents = {key =true,char=true,mouse_click=true,mouse_drag=true,mouse_scroll=true,menu_press=true,key_up=true,mouse_up=true}--I'm pretty sure this is spelled wrong

--[[
initRoutines brief:
If the coroutine is an active one or if it isn't active, but its event doesn't require it to be, proceed
If it is asking for this event, proceed
If the event is dealing with the mouse, do next
Check if it should be getting the mouse events, and if so, adjust them accordingly.

Resume the routine, collecting the next event it wants, and giving it the current events.
Repeat.
]]
function omni.initRoutines()
  local requests,natTerm,ok,err = {},term.current()
  game.l"Routine service starting NOW"
  while true do 
    local evts = {coroutine.yield()}
    for name,routineCo in pairs(routines) do 
      --game.l(name)
      if (active[name]) or (not foucusedEvents[evts[1]]) then
        --game.l"1"
        if (requests[name] ==evts[1]) or (not requests[name]) then 
          --game.l"2"
          if coroutine.status(routines[name]) ~="dead" then 
            curRout = name
            term.redirect(buffers[name])
            ok,requests[name] = coroutine.resume(routines[name],unpack(evts))
            --game.l("r "..name.." "..tostring(requests[name]).."+"..tostring(test))
            if not ok then 
              game.l("Routine "..name.." encountered error "..requests[name])
            end 
          else --RIP in peace
            --routines[name] = nil 
            game.l("Routine "..name.."("..tostring(requests[name])..") died. *NOT* GC'd.") game.l"a"
          end 
        end 
      end 
    end 
  end 
end 
local termx,termy=term.getSize()
function osStuff.spawnApp(name,funct,taskBackColor,taskTextColor,taskText) 
  name=name.."App"
  while routines[name] do 
    name=name.."|"
  end 
  omni.newRoutine(name,funct,true,termx,termy-1,true)
  buffers[name].setActivePos(1,2)
  props[name] = {}
  props[name].bufLocx = 1
  props[name].bufLocy = 2
  props[name].taskBackColor = taskBackColor
  props[name].taskTextColor = taskTextColor
  props[name].taskText = taskText
  props[name].type = 1--1 = fullscreen(ish) tabbed 
  props[name].menu = {}
  taskOrientation[#taskOrientation+1] = name
  local prev,a = curRout,term.current()
  curRout = name 
  term.redirect(buffers[name])
  local _ 
  _,requests[name]=coroutine.resume(routines[name])
  term.redirect(a)
  os.queueEvent"appSpawned"
  return name
end 
function osStuff.updateMenu(menutable)
  props[curRout].menu = menutable
  os.queueEvent"menu_update"
end 
function osStuff.returnTaskstuffs()
  return props,taskOrientation
end 
































--[[ye olde systeme
function omni.initRoutines()
  local cT = term.current()
  while true do 
    local a = {os.pullEvent()} -- Change to coroutine.yield
    term.redirect(cT)
    --buffers[active].blit(1,1)
    for i=1,#protected do 
      game.l("P "..protected[i])
      if routines[protected[i] ] then 
        game.l("x "..protected[i])
        if a[1] == (requests[protected[i] ] or a[1]) then 
          requests[protected[i] ] = coroutine.resume(routines[protected[i] ],unpack(a))
        end 
      end 
    end 
    -- User stuff:
    if a[1]=="mouse_click" or a[1]=="mouse_drag" or a[1]=="mouse_scroll" then 
      a[4]=a[4]-1
    end 
    for i,o in pairs(routines) do 
      game.l(i.."s "..coroutine.status(routines[i]))-------
      if coroutine.status(routines[active]) == "dead" then 
        --the active routine is dead!
      end 
      if i~=protected[i] and coroutine.status(routines[i]) == "suspended" then 
        --term.redirect(cT)
        term.redirect(buffers[i]) --------
        game.l("a: "..active)
        if active == i then 
          game.l('1 '..(tostring(requests[i]) or ""))
          if a[1]==(requests[i] or a[1]) then 
            --print"r"
            local _
            game.l("Resuming routine: "..active)
            _,requests[i] = coroutine.resume(routines[i],unpack(a))
            game.l(tostring(_))
            --print(requests[i])
          end 
        else 
          --go through events that need focous to recieve
          local bad
          local _
          for q,w in pairs(foucusedEvents) do 
            if a[1]==w then 
              bad = true 
            end 
          end 
          for k=1,#protected do 
            if protected[i]==k then
              bad=true 
            end
          end 
          if a[1]~=(requests[i] or "") then 
            bad=true 
          end 
          if (not bad) then 
            term.redirect(buffers[i])
            game.l("resuming "..i)
            _,requests[i]=coroutine.resume(routines[i],unpack(a))
            game.l(tostring(_))
            term.redirect(cT)
          end 
        end 
      end 
    end 
  end 
end 
--]]

--lang system:
local lang={}
--run the language file 
local b = fs.open('/library/lang/def',"r")
local c 
if b then 
  c = b.readAll()
  b.close()
end
print(fs.combine("/library/lang/",(c or "")))
local a = loadfile("/"..fs.combine("/library/lang/",(c or "")),lang)
if type(a) ~="function" then 
  print"\nWarning: Language file is missing or has errors. lan.osLookWeird. lan.exampleOfWeird"
  print("Error: "..tostring(a))
  sleep(4)
end
if a then 
  local ok,err=pcall(a)
  if not ok and err then 
    print("language file error:"..err)
    sleep(5)
  end 
else 
  print"\nWarning: Language file is missing or has errors. lan.osLookWeird. lan.exampleOfWeird"
  sleep(4)
end 
local lan = setmetatable({},{__index=function(self,input) local res,same = osStuff.g(input) if same then return "lan."..res end return res end })
function osStuff.g(a) -- This method allows for things like 'sudo.usage'
  local _langenv = {lang=lang}
  local f=load("return lang."..a,"langReturn", "t",_langenv)
  local ok,err = pcall(f)
  if err then 
    return err
  end 
  return a
end
function osStuff.p(a)
  print(osStuff.g(a))
end 
function osStuff.switchLanguage(newLang)
  local a = fs.open('/library/lang/def',"w")
  a.write(newLang)
  a.close()
end 




------------------------------
--[[~~~Clipboard System~~~]]--
------------------------------
local clipboardStuff  = {}
function osStuff.copyToClipboard(a) 
  if type(a) == "string" then 
    table.insert(clipboardStuff,1,a)
  end 
end 
function osStuff.removeFromClipboard(num)
  table.remove(clipboardStuff,num)
end 
function osStuff.getClipboard(a)
  return clipboardStuff 
end 

--[[Term fix :
function term.clearLine(l) 
  l= l or term.getCursorPos()
  local white = ""
  for i=1,term.getSize() do 
    white = white.." "
  end 
  local x,y = term.getCursorPos()
  --term.setBackgroundColor(colors.black)
  term.setCursorPos(1,l)
  print(white)
  term.setCursorPos(x,y)
end 
--]]
--A commonly used function:
function osStuff.prgName(path)
  string.gsub(path,"/","\\")
  local a
  while true do 
    a=string.find(path,"/")
    if not a then 
      break
    end 
    path = string.sub( path, a+1, #path )
  end 
  return path 
end 
function term.native()--don't let them bypass a buffer api
  return term.current()
end 

--Overwiting printerror to use our colorscheme 
function printError(txt)
  --log to console
  game.e("printError text: "..txt)
  term.setTextColor(osStuff.errorColor)
  print(txt)
  term.setTextColor(osStuff.textColor)
end 

--Part 2: 
--Â¥
--[[
ARgS:
1 - "nosplash" for no splash
2 - The program to run after bootup
3 - "nopass" to bypass the password. Note that there is no way you can get the boot function to do this before entering the password. The password lock is completely safe.
4 - "stop" will cause Newshell to ceise to initialize.
]]
--config:
--aliases
shell.setAlias("lock","/library/pswd")
shell.setAlias("oldEdit","/rom/programs/edit")
shell.setAlias("list","/library/programs/dir")
shell.setAlias("ls","/library/programs/dir")
local prs = fs.list"/library/programs/"
for i=1,#prs do 
  shell.setAlias(prs[i],"/library/programs/"..prs[i])
end 


--DEBUG:
shell.setAlias("a","/library/osStuff")
--force shell.programs to include our aliases
local a = shell.programs
function shell.programs(...)
  local b = a(...)
  b[#b+1] = "lock"
  b[#b+1] = "oldEdit"
  b[#b+1] = "startx"
  b[#b+1] = "console"
  for i=1,#prs do 
    b[#b+1] = prs[i]
  end 
  return b
end
local args={...}
local pastCommands={}
local tEnv = {}
tEnv["shell"] = shell--accsess to shell
tEnv["osStuff"] = osStuff --accsess to osStuffS
--api to tell if the program has cleared the screen
local didClear
local oldClear = term.clear 
function term.clear() 
  oldClear()
  didClear = true 
end 
function osStuff.didClear() return didClear end 
function osStuff.resetClear() didClear = false end 
local accType,accPass
local open = fs.open 
function osStuff.int()
  game.quit()
  os.loadAPI"Game-Engine/game"--this is to fix issues with term.redirect() inside game-engine, aswell as get it into the correct environment
  --Overwrite the Game-Engine console to work with this
  local gameWritetoConsole = game.writeToConsole
  function game.writeToConsole(txt)
    local year,month,day,clocktime,pm = osStuff.getTime()
    return gameWritetoConsole("["..(clocktime or "Clock service not started yet").."] "..txt)
  end 
  game.l = game.writeToConsole 
  function game.writeErrorToConsole(txt)
    game.writeToConsole("[ERROR] "..txt)
    return txt 
  end 
  game.e=game.writeErrorToConsole
  game.l"~~Console service restarted~~"
  osStuff.loadSettings()
  sleep(0)
  term.setBackgroundColor(osStuff.backColor or 1)
  term.setTextColor(osStuff.textColor or 1)
  term.clear()
  term.setCursorPos(1,1)
  term.setCursorBlink(false)
  local r = math.random(1,150)--1/50 chance to get easter egg
  if r==1 then 
    osStuff.specialPrint"GLaDOS V2"
    noSplash = false 
    osStuff.splashes = {"Oh, how are you holding up? BECAUSE I'M A POTATO."}
  elseif r==2 then 
    osStuff.specialPrint"Illuminati Secrets Browser V3"
    noSplash = false 
    osStuff.splashes = {"Yes, blame bush.\nIt makes our life MUCH easier."}
  elseif r==3 then 
    osStuff.specialPrint"Badwolf VBadwolf.badwolf"
    noSplash = false 
    osStuff.splashes={"Badwolf."}
  else 
    osStuff.specialPrint("[os] V"..tostring(osStuff.version))
  end
  --let's select from one of our fine splashes
  if args[1] ~="nosplash" then
    local whichSplash = math.random(1,#osStuff.splashes)
    --print the splash
    osStuff.specialPrint(osStuff.splashes[whichSplash])

  else 
    term.setCursorPos(1,2)
  end
  term.setCursorBlink(true)
  --request password
  if args[3]~="nopass" then 
    local a = loadfile"library/pswd"
    local ok,err,pss=pcall(a,open)--pswd is allowed full fs access
    accType = err
    accPass = pss
    if not ok then
      print"Could not open library/pswd. Hanging."
      while true do 
        coroutine.yield() 
      end 
    end 
  end
  --display MOTD
  local a = fs.open("/library/motd","r")
  local f 
  if a then 
    f = a.readAll() 
    a.close() 
  end 
  print(f or "a")
  if r==3 then 
    print"Badwolf badwolf to badwolf the badwolf."
  elseif r==2 then 
    print"Type Illuminati to start the secrets browser."
  elseif r==1 then 
    print"Type GLaDOS to start GLaDOS."
  else
    print"Run startx to start the GUI."
  end 
  if runProg then 
    pcall(function() shell.run(runProg) end)
  end 
  while true do 
    osStuff.doMain()
  end 
end

function osStuff.getDir(program)
  local remove = #fs.getName(program)
  return string.sub(program,1,#program-remove)
end 
------------------------------
--[[Time keeping functions]]--
------------------------------
local function getRealTime(dif,forward)
  if forward then 
    dif = dif.."+hours+from+now"
  else 
    dif=dif.."+hours+ago"
  end 
  local url = "http://chronic.herokuapp.com/utc/"
  --^ this is the best thing. ever. returns in plain text, and does not need a developer key. It makes my life so much easier.

  local utc = http.get(url..dif)

  if not utc then return false end
  utc = utc.readAll()
  if not utc then return false end 
  --print(utc)
  --get these into seperate variables
  local year = utc:sub(1,utc:find("-")-1)
  --print(utc:find"-")
  --print(year)
  local month = utc:sub(utc:find"-"+1,utc:find("-",utc:find"-"+1)-1)
  month=month:gsub(" ","")
  --print(month.."e")
  local day = utc:sub(utc:find("-",utc:find"-"+1)+1,utc:find(" "))
  day=day:gsub(" ","")
  --print(day.."e")
  local clocktime = utc:sub(utc:find" "+1,utc:find(" ",utc:find" "+1)-1)
  local pm
  if tonumber(clocktime:sub(1,2)) >= 13 and (not osStuff.miliTime) then
    clocktime= tostring(tonumber(clocktime:sub(1,2))-12)..string.sub(clocktime,3,#clocktime)
    pm=true
  end 
  clocktime=clocktime:gsub(" ","")
  --print(clocktime.."e")
  return year,month,day,clocktime,pm
end 
local function addsecond(clocktime)
  local seconds = clocktime:sub(#clocktime-1,#clocktime)
  seconds:gsub(":"," ")
  --print(seconds)
  seconds =seconds+1
  if seconds > 59 then 
    --instead of doing any further time calculations, just ask the server again. So, this means the server is asked every minute for the time.
    return false
  end
  
  local small
  if seconds <10 then 
    seconds = tostring(seconds)
    small = true 
    seconds = "0"..seconds 
  end 
  --print("c "..clocktime:sub(1,#clocktime-2))
  return clocktime:sub(1,#clocktime-2)..seconds
end 
local year,month,day,clocktime,pm
local function timekeeping()
  while true do
    if not clocktime then --if the server went down, we'll keep trying every second... hopefully we're not the cause of its downtime, or it's not going back up anytime soon, lol.
      year,month,day,clocktime,pm=getRealTime(osStuff.settings.timeDif,osStuff.settings.timeDifPlus)
    else
      local t = addsecond(clocktime)
      if t then 
        clocktime=t 
      else 
        year,month,day,clocktime,pm=getRealTime(osStuff.settings.timeDif,osStuff.settings.timeDifPlus)
      end 
      --print("Year "..year.." on the "..day.." of "..month..", "..clocktime)
      os.queueEvent"clocktick"
    end 
    sleep(1)
  end  
end 
function osStuff.getTime() return year,month,day,clocktime,pm end 
function osStuff.seperateTime(_d)
  if type(_d) ~="string" then return "6:66","6:66","6:66" end 
  return string.sub(_d,1,string.find(_d,",")-1),string.sub(_d,string.find(_d,",")+2,string.find(_d,",",string.find(_d,",")+1)-1),string.sub(_d,string.find(_d,",",string.find(_d,",")+1)+2,#_d) 
end 










--meta stuff, based of off lyqyd's code @ http://www.computercraft.info/forums2/index.php?/topic/18646-
--modifications to standard found @ http://jacksonmcneill.ddns.net/[os]_meta
-- Create local references to fs functions before they are modified
local accountType = "app" --Changing this can configure what apps are treated as. Treated as "app" by default.
-- Create local references to meta functions, as these could be changed by the user:

-- Create local references to overwritten fs functions
local isReadOnly = fs.isReadOnly
--Note: The open reference is above int, because it needs it
local delete = fs.delete
local copy = fs.copy 
local move = fs.move
local isDir = fs.isDir 
local combine = fs.combine
local exists = fs.exists
local list = fs.list 
-- I misunderstood this shell function ( :P ) so here's what I thought it did. I made a local reference anyway.
local function resolve(a)
  return combine(a,"")
end 
local getDir = osStuff.getDir
--Create a local reference to sleep
local sleep = sleep 
--Create a reference to os.time() on the last password attempt
local lastTime

--Settings stuff:
function osStuff.loadSettings()
  --open the file
  local f = open("library/settings","r")
  if not f then return false end 
  local fle = f.readAll()
  f.close()
  if not fle then return false end 
  fle = textutils.unserialize(fle)
  if not fle then return false end 
  print"y"
  for i,o in pairs(osStuff.settings) do 
    --[[game.l(tostring(i))
    game.l("s "..tostring(fle[i]))]]
    if fle[i] ~= nil then 
      osStuff.settings[i] = fle[i]
    end 
  end
end 
osStuff.loadSettings()

local function parseMeta(metaPath) -- Function by Lyqyd
  if exists(metaPath) then
    local handle = open(metaPath, "r")
    if handle then
      local data = {}
      local fn, err = load(handle.readAll(),"metaParseRead","t",data)
      handle.close()
      if fn then
        --setfenv(fn, data) ^^ replaccement
        local success, err = pcall(fn)
        if success then
          return data
        else
          return nil, err
        end
      else
        return nil, err
      end
    else
      return nil, "could not read metadata"
    end
  else
    return nil, "no metadata found"
  end
end 
function osStuff.getMetadataForFile(path) -- Function by lqyqd
  return parseMeta(combine(".meta", path))
end
local getFile = osStuff.getMetadataForFile
local function getMetadataForFolder(folderPath, metadata) -- Function by lqyyd and modified by Jackson McNeill
  if not metadata then metadata = {} end
  for _, file in ipairs(list(folderPath)) do
    local path = combine(folderPath, file)
    if isDir(path) then
      getMetadataForFolder(path, metadata)
    else
      --print('a '..path)
      metadata[path] = getFile(path)
    end
  end
  return metadata
end
osStuff.getMetadataForFolder=getMetadataForFolder
function osStuff.getAllMetadata() -- Function by Lyqyd
  if exists(".meta") and isDir(".meta") then
    return getMetadataForFolder(".meta")
  else
    return nil, "no metadata available"
  end
end
function osStuff.getLowestFolderPerms(folder,type) -- slightly copied from readonly
  local entire = getMetadataForFolder(folder)
  if not entire then return end 
  local result = 2
  for fileN,a in pairs(entire) do -- a is metadata
   -- print(fileN)print(a)
    local user
    --print(textutils.serialize(a))
    if a then 
      if a.permissions then 
        --print(a.permissions[type])
        user = a.permissions[type] or 2 
      end 
    end 
    user = user or 2 
    result = math.min(result,user) -- they both need the same priviliges or the other one is void 
  end
  return result 
end 
local getAllMeta = osStuff.getAllMetadata
local getMetaForFile = osStuff.getMetadataForFile -- We need a local reference so they cannot modify it
local lowestPerms = osStuff.getLowestFolderPerms
local function writeMeta(file,name,auth,ftype,times,perm,otherStuff)
  if string.sub(resolve(file),1,6)==".meta/" then
    return false 
  end 
  local a = getMetaForFile(file)
  --[[if isDir(file) then 
    return writeMeta(file.."/osFolderMetadata",name,auth,ftype,time,perm,otherStuff)
  end ]]
  if not a then --creating new 
    if game.inputCheck({file,name,auth,ftype,times,perm,otherStuff},{{"string"},{"string",},{"string",},{"string",},{"table",},{"table"},{"table","nil"}},"osStuff.writeMeta(internal)(new)") then 
      return false 
    end 
    a={}
    a.name = name
    a.author = auth
    a.type = ftype 
    a.timestamp = times 
    a.permissions = perm
  else --overwriting old
    if game.inputCheck({file,name,auth,ftype,times,perm,otherStuff},{{"string"},{"string","nil"},{"string","nil"},{"string","nil"},{"table","nil"},{"table","nil"},{"table","nil"}},"osStuff.writeMeta(internal)(changing)") then 
      return false 
    end
    a.name = name or a.name
    a.author = auth or a.author
    a.type = ftype or a.type 
    
    times = times or {}
    times.accessed = times.accessed or (a.timestamp or {}).accessed
    times.modified = times.modified or (a.timestamp or {}).modified
    times.created = times.created or (a.timestamp or {}).created
    a.timestamp = times or a.timestamp 
    perm = perm or {}
    perm.admin = perm.admin or (a.permissions or {}).admin
    perm.app = perm.app or (a.permissions or {}).app
    perm.guest = perm.guest or (a.permissions or {}).guest
    a.permissions = perm or a.permissions
  end 
  -- Are they an admin? 

  --write it
  local c =""
  --1.7.4 poor fix:
  a._ENV = nil 
  for i,o in pairs(a) do 
    if type(o)=="string" then 
      c=c..i.." = '"..o.."'\n"
    elseif type(o)=="table" then
      c=c..i.." = "..textutils.serialize(o).."\n"
    else 
      return game.e("Unexpected variable type while piecing together string: "..type(o))
    end 
  end
  --game.l(c) ----debug
  c=c.."\n"..(otherStuff or "")
  local b = open(combine(".meta", file),"w")
  if b then 
    b.write(c)
    b.close()
  else 
    return game.e("Could not open metadata for "..file.."!")
  end 

end 
function osStuff.writeMeta(file,name,auth,ftype,times,perm,pass)
  if lastTime then 
    if os.time()-lastTime <.02 then
      lastTime = os.time()
      return error"[os] Inputing passwords too quickly; please wait 1 second before trying a password!"
    end 
  end  
  if pass == accPass then 
    -- Do they have access?
    local b = getMetaForFile(file)
    if b then 
      if b.permissions then 
        if b.permissions[accType] then --we let them off if there's no perms set
          if b.permissions[accType] ~= 2 and accType ~= "admin" then
            return game.e"You do not have permission to access this file!"
          end 
        end 
      end
    end 
    if accType ~="admin" then 
      permissions = b.permissions or {}
      permissions.admin = 2 
      permissions.guest = 2
      --they are allowed to configure app permissions
    end 
    writeMeta(file,name,auth,ftype,times,perm)
    return true
  end 
  lastTime = os.time()
  return false

end 


function osStuff.appMeta(file,name,auth,ftype,times)
  local a = getMetaForFile(file)
  if not a then --creating new 
    if game.inputCheck({file,name,auth,ftype,times},{{"string"},{"string",},{"string",},{"string",},{"table",}},"appMeta(new)") then 
      return false 
    end
    local permissions = {admin = 2, guest = 2, apps = 2}
  else 
    if game.inputCheck({file,name,auth,ftype,times,perm},{{"string"},{"string","nil"},{"string","nil"},{"string","nil"},{"table","nil"},{"table","nil"}},"appMeta(changing)") then 
     --game.l"no"
      return false 
    end
    -- Do they even have access to this file? 
    local b = getMetaForFile(file)
    --we let them off if no permissions/no app permissions
    if b.permissions then 
      if b.permissions[accType] then 
        if b.permissions.app ~= 2 and b.permissions[accType] ~= 2 then  -- Not only do apps need perms to this, but the user using the app does too.
          if b.permissions.app or b.permissions[accType] then 
            return game.e"You do not have permission to access this file!"
          end 
        end 
      end 
    end 
  end 
  writeMeta(file,name,auth,ftype,permissions,times)
  return true 
end 








--]]



function fs.isReadOnly(file)
  if isDir(file) then 
    local level = math.min( lowestPerms(file,accType) , lowestPerms(file,accountType) )
    if level == 1 then 
      return true 
    elseif level == 0 then 
      return "noAccess"
    end 
  end 
  if string.sub(resolve(file),1,6) == ".meta/"  then 
    return true 
  end 
  local a = getFile(file)
  local user,app
  if a then 
    if a.permissions then 
      user = a.permissions[accType] or 2 
      app = a.permissions[accountType] or 2 
    end 
  end 
  user = user or 2 
  app = app or 2 
  local result = math.min(user,app) -- they both need the same priviliges or the other one is void 
  if result == 1 then 
    return true 
  elseif result == 0 then 
    return "noAccess"
  end 
  return isReadOnly(file )
end 
function osStuff.sudoReadOnly(file)
  if accType ~= "admin" then 
    if string.sub(resolve(file),1,6) == ".meta/"  then 
      return true 
    end
    local a = getFile(file)
    if a then 
      if a.permissions then 
        if a.permissions[accType] == 2 then 
          return
        elseif a.permissions[accType]== 1 then 
          return true 
        elseif a.permissions[accType] == 0 then 
          return "noAccess" 
        end 
      end 
    end 
  end 
end 

--old snippit from readOnly
--[[
      if a.permissions[accountType] then --apps
        if a.permissions[accType] == 1 then 
          if a.permissions[accountType] == 0 then --apps
            return "noAccess" -- Allows programs to support having no access, but unsupported programs will at least not try to write to the files
          elseif a.permissions[accountType]==1 then --aps
            return true 
          end 
        elseif a.permissions[accType]==0 then 
          return "noAccess"
        end 
        if a.permissions[accountType] == 1 then --apps
          return true 
        elseif a.permissions[accountType] == 0 then --apps
          return "noAccess" -- Allows programs to support having no access, but unsupported programs will at least not try to write to the files
        end 
      end 
    end 
  end --]]
local function n() return "Permission Denied"  end 
local function e() error "Permission Denied" end
local function t() end
local readOnly = fs.isReadOnly -- We have to create a local reference, or this could be easily edited.
function fs.open(file,mode)
  local a = readOnly(file) -- check meta/native read-only
  --print(a)
  if mode == "w" or mode == "a" then 
    if a then -- we'll need to return something special
      return { 
        write = e,
        writeLine = e,
        flush = e, 
        close = t,
      }
    else 
      if open(file,"r") then 
        writeMeta(file,nil,nil,nil,{modified = (month or "ERR")..", "..(day or "ERR")..", "..(clocktime or "ERR")})
      else 
        writeMeta(file,nil,nil,nil,{created = (month or "ERR")..", "..(day or "ERR")..", "..(clocktime or "ERR")})
      end
      return open(file,mode)
    end
  elseif mode == "r" then 
    if a == "noAccess" then 
      local readIt
      local rtn = {
        readLine = function() if not readIt then readIt = true return"Permission Denied"  end end, -- They will end up displaying this, most likely
        readAll = n,
        close = t,
      } 
      return rtn
    else 
      writeMeta(file,nil,nil,nil,{accessed = (month or "ERR")..", "..(day or "ERR")..", "..(clocktime or "ERR")}) -- If they overwrite this, they will achieve nothing.
      return open(file,mode)
    end 
  elseif mode =="rb" then 
    if a == "noAccess" then 
      return {
        read = n, -- They will end up displaying this, most likely
        close = t,
      } 
    else 
      return open(file,mode)
    end 
  elseif mode == "wb" or mode == "ab" then 
    if a then 
      return {
        readLine = t,
        close = t,
        flush = t,
      } 
    else 
      return open(file,mode)
    end 
  end 
end 
function fs.copy(a,b)
  local c = readOnly(a) 
  local d = readOnly(b) 
  if d  == "noAccess" or d then
    e()
    return -- Just in case
  elseif c == "noAccess" then 
    e() 
    return -- Just in case
  end -- Copy the metadata
  copy( fs.combine( ".meta" , a ) , fs.combine( ".meta", b ) )
  return copy(a,b)
end
function fs.move(a,b)-- based of copy
  local c = readOnly(a) 
  local d = readOnly(b) 
  if d then
    e()
    return -- Just in case
  elseif c then 
    e() 
    return -- Just in case
  end 
  --move the metadata
  pcall(  function()  move( fs.combine( ".meta" , a ) , fs.combine( ".meta", b ) )   end  )
  return move(a,b)
end
function fs.delete(a)
  local b = readOnly(a)
  if b then 
    e() 
    return -- Just in case
  end 
  --delete metadata
  delete( fs.combine( ".meta" , a ) )
  return delete(a) 
end
local function check(file,mode,pass)
  game.l(file )
  if lastTime then 
    if os.time()-lastTime <.02 then
      lastTime = os.time()
      game.l"e"
      return error(osStuff.g"tooManyPasswords")
    end 
  end  
  if pass == accPass then 
    -- Do they have access?
    if accType ~="admin" then
    game.l"n" 
      local b = getMetaForFile(file)
      if b then 
        if b.permissions then 
          if b.permissions[accType] then --we let them off if there's no perms set
            if b.permissions[accType] ~= 2 then 
              if not ( mode ~="a" and mode ~="w" and b.permissions[accType] == 1 ) then 
                return false,game.e"You do not have permission to access this file!"
              end 
            end
          end 
        end  
      end 
      --Are they trying to access metadata as a non-admin?
      if string.sub(resolve(file),1,6) == ".meta/"  then 
        lastTime = os.time()
        return "w"
      end 
    end 
    game.l"Y"
    return true
  end 
  lastTime = os.time()
  return "w"
end
function osStuff.open(file,mode,pass)
  game.l("o "..file)
  if check(file,mode,pass) ==true then
    return open(file,mode)
  end 
end  

-- A c&p'd function
function osStuff.delete(file,pass)
  if check(file,"w",pass) ==true then
    return delete(file)
  end 
end  
function osStuff.move(file1,file2,pass)
  if check(file1,"w",pass) ==true and check(file2,"w",pass)==true then
    return move(file1,file2)
  end 
end  
function osStuff.copy(file1,file2,pass)
  if check(file1,"r",pass) ==true and check(file2,"w",pass)==true then
    return copy(file1,file2)
  end 
end  



-------------------
--[[Misc. stuff]]--
-------------------
local function shallowcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
          copy[orig_key] = orig_value
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end
local DONOTENABLE = true -- If this is the update that added the GUI, then this is okay to be true. If it's any later than that at all, tell me. Also tell me to remove this comment afterwards.7
--IF THIS IS ENABLED BE DEFAULT, THEN I F**KED UP! FOR THE LOVE OF ALL THAT IS PROTECTED, TELL ME!
local function stillneivecopy(orig)
  local copy = {}
  for i,o in pairs(orig) do 
    if (i~="omni" or DONOTENABLE) then  
      copy[i] = shallowcopy(o)
    end 
  end
  return copy
end 
local runningProgram
local cur = term.current()
env = stillneivecopy(_G)
--env = _G


env.os.pullEvent = ospe
local function run(prg,pargs)
  pargs = pargs or {}
  if not prg then 
    printError(osStuff.g"Nothing"..osStuff.g"noExist")
  else
    local prog=env.shell.resolveProgram(prg)
    runningProgram = prog
    if prog then 
      local failed
      prog,failed = loadfile(prog,env)
      if type(prog)=="function" then 
        --setfenv(prog,env)          ^ replacement
        local ok,err = pcall(function() prog(unpack(pargs)) end)
        if (not ok) and err then 
          printError(err)
        end 
      else 
        if failed then 
          printError(failed)
        end 
      end 
    else 
      printError(input..osStuff.g"noExist")
    end 
  end 
end 
function env.os.loadAPI(path)
  local _env = setmetatable({},{__index=env})
  local pg,err = loadfile(path,_env)
  if pg then
    setfenv(pg,_env)  --^ replacement
    pg()
  else 
    printError(err)
  end
  local cont = {} 
  for i,o in pairs(_env) do 
    cont[i] = o 
  end 
  env[fs.getName(path)] = cont
  return true 
end 
local function tokenise( ... ) -- Taken from CC's shell/bios
    local sLine = table.concat( { ... }, " " )
  local tWords = {}
    local bQuoted = false
    for match in string.gmatch( sLine .. "\"", "(.-)\"" ) do
        if bQuoted then
            table.insert( tWords, match )
        else
            for m in string.gmatch( match, "[^ \t]+" ) do
                table.insert( tWords, m )
            end
        end
        bQuoted = not bQuoted
    end
    return tWords
end
function os.run( _tEnv, _sPath, ... )
    local tArgs = { ... }
    local tEnv = _tEnv
    setmetatable( tEnv, { __index = env } )
    local fnFile, err = loadfile( _sPath , tEnv)
    if fnFile then
        --setmetatable( tEnv, { __index = function(t,k) return _G[k] end } )
        --setfenv( fnFile, tEnv ) replaced in loadfile
        local ok, err = pcall( function()
            fnFile( unpack( tArgs ) )
        end )
        if not ok then
            if err and err ~= "" then
                printError( err )
            end
            return false
        end
        return true
    end
    if err and err ~= "" then
        printError( err )
    end
    return false
end

function env.shell.run( ... )
  local tWords = tokenise( ... )
  local sCommand = tWords[1]
  if sCommand then
    return run( sCommand, unpack( tWords, 2 ) )
  end
  return false
end
local function noSupport() printError"Sorry, [os] does not support multishell shell functions." end 
env.shell.openTab = noSupport
env.shell.switchTab = noSupport
env.lan = lan
function env.shell.getRunningProgram() return runningProgram end 
function osStuff.newDaemon(funct,name)
  if not routines[name.."d"] then 
    --setfenv(funct,env) unnesiary
    omni.newRoutine(name.."d",funct,false)
  else 
    error("Daemon "..name.." already exists!")
  end 
end 
env.osStuff.newDaemon = osStuff.newDaemon
local oldRe = env.term.redirect
function env.term.redirect(obj)
  buffers[curRout] = obj 
  oldRe(obj)
  if not env.term.write == obj.write then 
    game.e"Failed to redirect the term!"
  end 
  os.queueEvent"redirected"
  coroutine.yield()
end


function osStuff.doMain()
  osStuff.doDir()
  --read input
  term.setBackgroundColor(osStuff.backColor or 1)
  term.setTextColor(osStuff.textColor or 1)
  input = read(nil,pastCommands)
  --add this to prev commands
  if string.find(input,"%a") or string.find(input,"%d") then 
    pastCommands[#pastCommands+1]=input
  end
  --sub the first part of the string out
  local inFirstChar = string.sub(input,1,1) -- This section in need of recode
  if inFirstChar ~=";" and inFirstChar~=":" then
    --top priority: make it look cool, of course!
    local _,y=term.getCursorPos()
    term.setCursorPos(1,y-1)
    osStuff.doDir()
    term.setTextColor(osStuff.commandColor or 1)
    --write(inFirstChar)
    term.setTextColor(osStuff.textColor or 1)
    --kindly done for me:
    --input=string.sub(input,2,#input)
    --write(input)
    print() --move back to normal line
    --[[if input =="clear" then
      local runThis = loadfile"library/newClear"
      runThis()
    elseif input=="wipe"then
      local runThis=loadfile"library/wipe"
      runThis()
    elseif input=="settings"then
    
      local runThis=loadfile"library/settings"
      runThis=osStuff.giveFenv(runThis)
      runThis()
    else
      
    end]]
    if input == "console" then 
      game.openConsole()
    --[[elseif input == "startx" then 
      if term.isColor() then 
        --start the GUI
        print"not done"
        print"^^Ignore that! He's lying!"

        print"The GUI interface is starting NOW!"
      else 
        osStuff.p"noBasicGUI"
      end]]
    else 
      osStuff.resetClear()
      -- Execute the program
      local pargs = tokenise(input)
      local failed
      if not pargs[1] then 
        printError(osStuff.g"Nothing"..osStuff.g"noExist")
      else
        local prog=shell.resolveProgram(pargs[1])
        runningProgram = prog
        failed = pargs[1]
        table.remove(pargs,1)
        if prog then 
          local failed
          prog,failed = loadfile(prog,env)
          if type(prog)=="function" then 
            --setfenv(prog,env) replaced at loadfile
            local ok,err = pcall(function() prog(unpack(pargs)) end)
            term.redirect(cur)
            if (not ok) and err then 
              printError(err)
            end 
          else 
            if failed then 
              printError(failed)
            end 
          end 
        else 
          printError(failed..osStuff.g"noExist")
        end 
      end 
      if osStuff.didClear() then 
        local _,cury = term.getCursorPos()
        local _,termy = term.getSize()        
        term.setBackgroundColor(osStuff.backColor)
        for i=cury,termy do           
          term.setCursorPos(1,i)
          term.clearLine()
        end

        term.setCursorPos(1,cury)
      end 
      -- Reset background colors: 
      term.setBackgroundColor(osStuff.backColor)
      term.setTextColor(osStuff.commandColor)
    end
  else
    local inputF
    --they're running a lua command
    local _,y=term.getCursorPos()
    term.setCursorPos(1,y-1)
    osStuff.doDir()
    term.setTextColor(osStuff.promptColor or 1)
    term.setTextColor(osStuff.commandColor or 1)
    write(inFirstChar)
    term.setTextColor(osStuff.textColor or 1)
    input=string.sub(input,2,#input)
    print(input)
    --make it into a command:
    --[[Brief:
    If it will work as "return ".. , 1
    If it will work as plain, 2
    --
    1:
    Print what it returns
    --
    2: 
    Print the value through serialization
    ]]
    local returnAsVar = loadstring(" return "..input)
    local normal = loadstring(input)
    if type(returnAsVar) == "function" then 
      normal = returnAsVar
    elseif type(normal) ~="function" then 
      printError(normal)
    end 
    setfenv(normal,env) 
    local ok,res = pcall(normal)
    if ok then 
      local ok2, res2 = pcall(textutils.serialize, res)
      if ok2 then 
        print(res2)
      else 
        print(tostring(res))
      end 
    else 
      printError(res)
    end 
  end
end

env.osStuff.doMain = osStuff.doMain --doMain would get discluded otherwise.
topEnv = true
if args[4]~="stop" then 
  --osStuff.int()
  print"start"
  omni.newRoutine("term",osStuff.int,false)
  osStuff.newDaemon(timekeeping,"time")
  omni.makeActive("term")
  print"startroutines"
  omni.initRoutines()
end 
game.l"[OS] Has finished executing. This is NOT supposed to happen!"
